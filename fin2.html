<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rail + Drawer Frame Builder (mm)</title>
<style>
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#111;color:#111}
  .app{display:grid;grid-template-columns:1.25fr 1fr;height:100%}

  /* views grid */
  .views{display:grid;grid-template-columns:1fr 1fr;grid-template-rows:1fr 1fr;gap:.5rem;background:#111;padding:.5rem;min-width:0}
  .view{position:relative;min-height:0;border-radius:.5rem;overflow:hidden;background:#000}
  canvas{width:100%;height:100%;display:block}
  .hud{position:absolute;left:.5rem;top:.5rem;background:rgba(0,0,0,.55);color:#fff;font-size:12px;padding:.2rem .4rem;border-radius:.3rem}
  .fit{position:absolute;right:.5rem;top:.5rem;background:rgba(0,0,0,.65);color:#fff;font-size:12px;padding:.24rem .5rem;border:none;border-radius:.3rem;cursor:pointer}
  .legend{position:absolute;right:.5rem;bottom:.5rem;background:rgba(0,0,0,.55);color:#fff;font-size:11px;padding:.2rem .4rem;border-radius:.3rem}

  /* right panel */
  .panel{background:#f7f7f8;padding:1rem 1.25rem;overflow:auto}
  .toolbar{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
  .pill{border:1px solid #bbb;padding:.35rem .6rem;border-radius:.4rem;background:#fff;cursor:pointer}
  .seg{padding:.25rem .6rem;border:1px solid #bbb;background:#fff;border-radius:.4rem;cursor:pointer}
  .seg.active{background:#222;color:#fff;border-color:#222}

  /* small layout helpers for controls */
  .row{display:flex;gap:.6rem;align-items:center;flex-wrap:wrap;margin:.25rem 0}
  .ctl{display:flex;flex-direction:column;gap:.25rem;min-width:140px}
  .l{display:flex;align-items:center;gap:.4rem}
  .dim{color:#666;font-size:12px}

  /* single-view modes */
  .views.mode-3d  #vplan, .views.mode-3d  #vfront, .views.mode-3d  #vside { display:none }
  .views.mode-plan#v3d,  .views.mode-plan#vfront,.views.mode-plan#vside { display:none }
  .views.mode-front#v3d, .views.mode-front#vplan, .views.mode-front#vside{ display:none }
  .views.mode-side #v3d, .views.mode-side #vplan, .views.mode-side #vfront{ display:none }
  .views.mode-3d  #v3d,
  .views.mode-plan#vplan,
  .views.mode-front#vfront,
  .views.mode-side #vside { grid-column:1 / span 2; grid-row:1 / span 2 }

  /* cut list drawer */
  .cutdrawer{
    position:fixed; right:0; top:0; height:100%; width:min(420px, 92vw);
    background:#fff; color:#111; box-shadow:-8px 0 20px rgba(0,0,0,.35);
    transform:translateX(100%); transition:transform .25s ease; z-index:30; padding:16px 18px; overflow:auto
  }
  .cutdrawer.open{ transform:translateX(0) }
  .cutdrawer h2{ margin:.2rem 0 1rem }
</style>
</head>
<body>
<div class="app">
  <!-- left: views -->
  <div class="views" id="views">
    <div class="view" id="v3d">
      <div class="hud" id="hud3d">3D</div>
      <button class="fit" id="fit3d">Fit view</button>
      <canvas></canvas>
      <div class="legend">Posts: pink · Lintels: gray · Rails: blue · Supports: orange · Bins: red</div>
    </div>
    <div class="view" id="vplan">
      <div class="hud">TOP / Plan (X×Z)</div>
      <canvas></canvas>
      <div class="legend">Openings & rail footprints</div>
    </div>
    <div class="view" id="vfront">
      <div class="hud">FRONT / Elevation (X×Y)</div>
      <canvas></canvas>
      <div class="legend">Overall W/H, openings, clearances</div>
    </div>
    <div class="view" id="vside">
      <div class="hud">SIDE / Elevation (Z×Y)</div>
      <canvas></canvas>
      <div class="legend">Depth & rail length</div>
    </div>
  </div>

  <!-- right: controls -->
  <div class="panel">
    <div class="toolbar">
      <h1 style="margin-right:auto">Rail + Drawer Frame Builder (mm)</h1>
      <span>View:</span>
      <button class="seg active" data-mode="quad">Quad</button>
      <button class="seg" data-mode="3d">3D</button>
      <button class="seg" data-mode="plan">Plan</button>
      <button class="seg" data-mode="front">Front</button>
      <button class="seg" data-mode="side">Side</button>
      <button class="pill" id="toggleQuad3D">Quad ⇄ 3D</button>
      <button class="pill" id="toggleCutList">Cut List</button>
    </div>

    <div id="controlsRoot"></div>
  </div>
</div>

<!-- same-page Cut List drawer -->
<div id="cutDrawer" class="cutdrawer">
  <div class="row" style="justify-content:space-between;align-items:center">
    <h2>Cut List</h2>
    <button class="pill" id="closeCutList">Close</button>
  </div>
  <div id="cutListTable" class="ctl" style="gap:.6rem"></div>
  <div class="row" style="margin-top:.6rem">
    <button class="pill" id="exportCSV">Export CSV</button>
    <a id="csvDownload" class="link" style="display:none">Download CSV</a>
    <div id="cutTotals" class="dim"></div>
  </div>
</div>
<script>
/* ===================== Single-source model + UI + renderers ===================== */

/* ---------- colors (JS constants; canvas doesn't parse CSS vars reliably) ---------- */
const COLORS = {
  bg:'#0b0b0b', grid:'#1e1e1e', line:'#cfcfcf',
  post:'#f5dfe0', lintel:'#e8e8e8',
  rail:'#c9e1ff', railEdge:'#355',
  support:'#f6c16c', support2:'#f3a64f',
  bin:'#ffb3b3', edge:'#333', text:'#dddddd'
};

/* ---------- utils ---------- */
const $ = (q)=>document.querySelector(q);
const clamp = (v,a,b)=>Math.max(a,Math.min(b,Number(v||0)));
const mm = (v)=>Number(String(v).replace(/[^0-9.\-]/g,"")||0);
function sum(a){return a.reduce((x,y)=>x+y,0);}
function drawGrid(ctx,w,h){
  ctx.fillStyle = COLORS.bg; ctx.fillRect(0,0,w,h);
  ctx.strokeStyle = COLORS.grid;
  for(let x=0;x<w;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
  for(let y=0;y<h;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
}
function drawDim(ctx,x1,y1,x2,y2,label,align='center'){
  ctx.strokeStyle='#bbb'; ctx.fillStyle=COLORS.text;
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  const mx=(x1+x2)/2, my=(y1+y2)/2;
  ctx.font='11px system-ui, sans-serif'; ctx.textAlign=align; ctx.textBaseline='middle';
  ctx.fillText(label, mx, my);
}

/* ---------- opening calculator helpers ---------- */
function openingFlangeOnLedge({Body,Lip,Slack}) {
  return Math.ceil(mm(Body) + 2*mm(Lip) + mm(Slack));
}
function openingUnderLipBite({Body,Bite,Inside,P}) {
  return Math.ceil(mm(Body) + 2*(mm(P) - mm(Bite)) + mm(Inside));
}
function recDrawerWidth(opening, runnerSide, clearanceSide){
  return Math.max(0, Math.round(mm(opening) - 2*(mm(runnerSide)+mm(clearanceSide))));
}

/* ---------- state (defaults) ---------- */
const state = {
  // timber / overall
  post:43, depth:420, drawerDepth:420, runnerDepth:420,
  topCap:2, bottomCap:2, topClear:0, bottomClear:0,
  rearFrame:true,

  // columns & rows
  openingTargets:[325,325,325,325],
  rowHeights:[120,120,120,120,120,120],

  // rails & supports
  twoRailsPerOpening:true,
  topSupport:true, topKind:'upright', topSupportOutside:false, topUprightH:150, topDrop:10,
  bottomSupport:false, bottomKind:'batten', bottomSupportOutside:false, bottomLift:8, bottomUprightH:150,
  extraBottomBeam:false, extraBottomOutside:false, extraBottomLift:0,

  // bins (visual)
  showBins:true, binBody:300, binFlange:9.5, binWall:2.5,
  binHeights:[145,95,95,95,95,95],
  lockBinToRow:true,

  // rail length rule
  railRule:'fromDrawer',   // 'fromDrawer' | 'fromRunner'
  railAllowance:0,
  allowSpacer:false,
  spacerTotal:0,

  // opening calculator
  calcMode:'flange', // 'flange' | 'underlip'
  calcA:{Body:300, Lip:9.5, Slack:6},
  calcB:{Body:300, Bite:9, Inside:4},

  // drawer HW
  openingTargetForDrawer:283, runnerSide:10, clearSide:1,

  // view state
  yaw:0.5, pitch:0.3, zoom:1
};

/* ---------- derived helpers ---------- */
function segments(st){
  const seg=[st.post];
  st.openingTargets.forEach(w=>{ seg.push(mm(w)); seg.push(st.post); });
  return seg;
}
function channels(st){
  const P=st.post, seg=segments(st); const out=[]; let x=0;
  for(const s of seg){ if(s>P) out.push({x, w:s}); x+=s; }
  return out;
}
function autoHeight(st){
  const P=st.post;
  const rails = st.rowHeights.length * P;
  return st.topCap + P + st.topClear + sum(st.rowHeights) + rails + st.bottomClear + P + st.bottomCap;
}
function levels(st){
  const P=st.post; let y=P + st.topClear; const arr=[];
  for(let i=0;i<st.rowHeights.length;i++){
    arr.push(y);
    y += st.rowHeights[i] + P;
  }
  return arr;
}
function railLength(st){
  // From drawer depth ± allowance; limited by cabinet depth + optional spacer allowance.
  if(state.railRule==='fromDrawer'){
    const desired = mm(st.drawerDepth) + mm(st.railAllowance);
    const capacity = mm(st.depth) + (st.allowSpacer ? mm(st.spacerTotal) : 0);
    return clamp(desired, 1, capacity);
  }
  // or use runnerDepth as-is (clamped to cabinet depth)
  return Math.max(1, Math.min(mm(st.runnerDepth), mm(st.depth)));
}

/* ---------- model (single source of truth) ---------- */
function buildModel(st){
  const P=st.post, W=sum(segments(st)), H=autoHeight(st), D=st.depth;
  const L=levels(st), ch=channels(st), rLen=railLength(st);
  const boxes=[]; // {x,y,z,w,h,d, type}

  // posts (front)
  let x=0; for(const s of segments(st)){ if(s===P) boxes.push({x, y:0, z:0, w:P, h:H, d:P, type:'post'}); x+=s; }
  // posts (rear)
  if(st.rearFrame){ let xb=0; for(const s of segments(st)){ if(s===P) boxes.push({x:xb, y:0, z:D-P, w:P, h:H, d:P, type:'postRear'}); xb+=s; } }

  // lintels (front + rear)
  boxes.push({x:0,y:0,z:0,w:W,h:P,d:P,type:'lintel'});
  boxes.push({x:0,y:H-P,z:0,w:W,h:P,d:P,type:'lintel'});
  if(st.rearFrame){
    boxes.push({x:0,y:0,z:D-P,w:W,h:P,d:P,type:'lintelRear'});
    boxes.push({x:0,y:H-P,z:D-P,w:W,h:P,d:P,type:'lintelRear'});
  }

  // supports
  if(st.topSupport){
    if(st.topKind==='batten'){
      const yIn = clamp(P + st.topDrop, P, H-2*P);
      const y = st.topSupportOutside ? -P : yIn;
      boxes.push({x:0,y,z:0,w:W,h:P,d:rLen,type:'support'});
      if(st.rearFrame) boxes.push({x:0,y,z:D-rLen,w:W,h:P,d:rLen,type:'supportGhost'});
    }else{
      const h = clamp(st.topUprightH, 1, H);
      const y0 = st.topSupportOutside ? -P : P; // from top lintel underside
      boxes.push({x:(W-P)/2,y:y0,z:(D-P)/2,w:P,h, d:P,type:'support2'});
    }
  }
  if(st.bottomSupport){
    if(st.bottomKind==='batten'){
      const yIn = clamp(H-2*P - st.bottomLift, P, H-2*P);
      const y = st.bottomSupportOutside ? H : yIn;
      boxes.push({x:0,y,z:0,w:W,h:P,d:rLen,type:'support'});
      if(st.rearFrame) boxes.push({x:0,y,z:D-rLen,w:W,h:P,d:rLen,type:'supportGhost'});
    }else{
      const h = clamp(st.bottomUprightH, 1, H);
      const base = st.bottomSupportOutside ? H : (H-P);
      const y0 = Math.max(0, base - h);
      boxes.push({x:(W-P)/2,y:y0,z:(D-P)/2,w:P,h, d:P,type:'support2'});
    }
  }
  if(st.extraBottomBeam){
    const yIn = clamp(H-2*P - st.extraBottomLift, P, H-2*P);
    const y = st.extraBottomOutside ? H : yIn;
    boxes.push({x:0,y,z:0,w:W,h:P,d:rLen,type:'support2'});
    if(st.rearFrame) boxes.push({x:0,y,z:D-rLen,w:W,h:P,d:rLen,type:'supportGhost'});
  }

  // drawer rails
  ch.forEach(c=>{
    const bxList = st.twoRailsPerOpening ? [c.x, c.x + c.w - P] : [c.x + (c.w - P)/2];
    bxList.forEach(bx => L.forEach(y => boxes.push({x:bx,y,z:0,w:P,h:P,d:rLen,type:'rail'})));
  });

  // bins (visual)
  if(st.showBins){
    ch.forEach(c=>{
      const overall = st.binBody + 2*st.binFlange;
      const w = Math.min(overall, c.w-2);
      const bx = c.x + (c.w - w)/2;
      L.forEach((y,ri)=>{
        const rowH = st.rowHeights[ri] ?? 95;
        const presetH = st.binHeights[ri] ?? rowH;
        const h = state.lockBinToRow ? rowH : presetH;
        boxes.push({x:bx, y:y+P, z:0, w, h, d:rLen, type:'bin'});
      });
    });
  }

  // bounds
  const min=[Infinity,Infinity,Infinity], max=[-Infinity,-Infinity,-Infinity];
  boxes.forEach(b=>{
    min[0]=Math.min(min[0], b.x); min[1]=Math.min(min[1], b.y); min[2]=Math.min(min[2], b.z);
    max[0]=Math.max(max[0], b.x+b.w); max[1]=Math.max(max[1], b.y+b.h); max[2]=Math.max(max[2], b.z+b.d);
  });
  if(!boxes.length){ boxes.push({x:0,y:0,z:0,w:10,h:10,d:10,type:'dummy'}); min[0]=min[1]=min[2]=0; max[0]=max[1]=max[2]=10; }

  return {W,H,D,P, channels:ch, levels:L, boxes, bounds:{min,max}};
}

/* ---------- 2D renderers (read model) ---------- */
let c3d, cp, cf, cs;
function renderPlan(model){
  const cvs=cp, ctx=cvs.getContext('2d');
  const r=cvs.getBoundingClientRect(), dpr=window.devicePixelRatio||1;
  if(cvs.width!==Math.floor(r.width*dpr) || cvs.height!==Math.floor(r.height*dpr)){
    cvs.width=Math.floor(r.width*dpr); cvs.height=Math.floor(r.height*dpr); ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  const {W,D,P} = model;
  drawGrid(ctx, r.width, r.height);
  const pad=26, s=Math.min((r.width-2*pad)/W, (r.height-2*pad)/D), ox=pad, oy=pad;

  // outer
  ctx.strokeStyle=COLORS.line; ctx.lineWidth=1; ctx.strokeRect(ox,oy, W*s, D*s);
  drawDim(ctx, ox, oy-12, ox+W*s, oy-12, `W ${W} mm`);

  // front posts
  segments(state).reduce((x,s)=>{
    if(s===P){ ctx.fillStyle=COLORS.post; ctx.fillRect(ox+x*s, oy, P*s, D*s); }
    return x+s;
  },0);

  // rear post corners
  if(state.rearFrame){
    segments(state).reduce((x,s)=>{
      if(s===P){ ctx.fillStyle='rgba(245,223,224,.65)'; ctx.fillRect(ox+x*s, oy+(D-P)*s, P*s, P*s); }
      return x+s;
    },0);
  }

  // opening dims
  model.channels.forEach((c)=>{
    const cx=ox + c.x*s, cw=c.w*s;
    drawDim(ctx, cx, oy+D*s+12, cx+cw, oy+D*s+12, `${c.w} mm`);
  });

  // rail footprints
  model.boxes.filter(b=>b.type==='rail').forEach(b=>{
    ctx.fillStyle='rgba(43,102,255,.35)';
    ctx.fillRect(ox + b.x*s, oy + b.z*s, b.w*s, Math.min(b.d,D)*s);
  });
}

function renderFront(model){
  const cvs=cf, ctx=cvs.getContext('2d');
  const r=cvs.getBoundingClientRect(), dpr=window.devicePixelRatio||1;
  if(cvs.width!==Math.floor(r.width*dpr) || cvs.height!==Math.floor(r.height*dpr)){
    cvs.width=Math.floor(r.width*dpr); cvs.height=Math.floor(r.height*dpr); ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  const {W,H,P} = model;
  drawGrid(ctx, r.width, r.height);
  const pad=26, s=Math.min((r.width-2*pad)/W, (r.height-2*pad)/H), ox=pad, oy=pad;

  ctx.strokeStyle=COLORS.line; ctx.strokeRect(ox,oy, W*s, H*s);
  drawDim(ctx, ox, oy-12, ox+W*s, oy-12, `W ${W} mm`);
  drawDim(ctx, ox+W*s+12, oy, ox+W*s+12, oy+H*s, `H ${H} mm`, 'left');

  model.boxes.forEach(b=>{
    const x=ox+b.x*s, y=oy+b.y*s, w=b.w*s, h=b.h*s;
    if(b.type==='post')        { ctx.fillStyle=COLORS.post;   ctx.fillRect(x,y,w,h); }
    if(b.type==='lintel')      { ctx.fillStyle=COLORS.lintel; ctx.fillRect(x,y,w,h); }
    if(b.type==='rail')        { ctx.fillStyle=COLORS.rail;   ctx.fillRect(x,y,w,h); }
    if(b.type==='support')     { ctx.fillStyle=COLORS.support;ctx.fillRect(x,y,w,h); }
    if(b.type==='support2')    { ctx.fillStyle=COLORS.support2;ctx.fillRect(x,y,w,h); }
    if(b.type==='bin')         { ctx.fillStyle=COLORS.bin; ctx.globalAlpha=.75; ctx.fillRect(x,y,w,h); ctx.globalAlpha=1; }
  });

  // openings + clearances
  model.channels.forEach(c=>{
    const cx=ox+c.x*s, cw=c.w*s;
    drawDim(ctx, cx, oy+H*s+12, cx+cw, oy+H*s+12, `${c.w} mm`);
  });
  if(model.levels.length){
    const y0 = model.levels[0];
    drawDim(ctx, ox-12, oy+P*s, ox-12, oy+y0*s, `Top clr ${(y0-P).toFixed(0)} mm`, 'right');
    const last = model.levels[model.levels.length-1];
    const lastH = state.rowHeights[state.rowHeights.length-1]||0;
    const yEnd = last + P + lastH;
    drawDim(ctx, ox+W*s+24, oy + Math.min(yEnd,H-P)*s, ox+W*s+24, oy+(H-P)*s, `Bottom clr ${Math.max(0,H-P-yEnd).toFixed(0)} mm`, 'left');
  }
}

function renderSide(model){
  const cvs=cs, ctx=cvs.getContext('2d');
  const r=cvs.getBoundingClientRect(), dpr=window.devicePixelRatio||1;
  if(cvs.width!==Math.floor(r.width*dpr) || cvs.height!==Math.floor(r.height*dpr)){
    cvs.width=Math.floor(r.width*dpr); cvs.height=Math.floor(r.height*dpr); ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  const {H,D,P} = model;
  drawGrid(ctx, r.width, r.height);
  const pad=26, s=Math.min((r.width-2*pad)/D, (r.height-2*pad)/H), ox=pad, oy=pad;

  ctx.strokeStyle=COLORS.line; ctx.strokeRect(ox,oy, D*s, H*s);
  drawDim(ctx, ox, oy-12, ox+D*s, oy-12, `D ${D} mm`);
  const rLen = railLength(state);
  drawDim(ctx, ox, oy-28, ox+Math.min(rLen, D)*s, oy-28, `Rail length ${Math.min(rLen,D)} mm`);

  model.levels.forEach(y=>{
    ctx.fillStyle=COLORS.rail;
    ctx.fillRect(ox, oy + y*s, Math.min(rLen, D)*s, P*s);
  });

  model.boxes.forEach(b=>{
    if(b.type==='support' || b.type==='support2'){
      ctx.fillStyle = (b.type==='support')?COLORS.support:COLORS.support2;
      ctx.fillRect(ox, oy + b.y*s, Math.min(b.d,D)*s, P*s);
    }
  });

  model.boxes.filter(b=>b.type==='bin').forEach(b=>{
    ctx.fillStyle=COLORS.bin; ctx.globalAlpha=.75;
    ctx.fillRect(ox, oy + b.y*s, D*s, b.h*s);
    ctx.globalAlpha=1;
  });
}

/* ---------- 3D renderer ---------- */
function rgba(hex,a){ const c=hex.replace('#',''); const r=parseInt(c.slice(0,2),16), g=parseInt(c.slice(2,4),16), b=parseInt(c.slice(4,6),16); return `rgba(${r},${g},${b},${a})`; }
function makeFaces(x,y,z,w,h,d,color="#ddd",alpha=1,edge="#333"){
  const v=[[x,y,z],[x+w,y,z],[x+w,y+h,z],[x,y+h,z],[x,y,z+d],[x+w,y,z+d],[x+w,y+h,z+d],[x,y+h,z+d]];
  const q=[[0,1,2,3],[4,5,6,7],[0,4,7,3],[1,5,6,2],[0,1,5,4],[3,2,6,7]];
  return q.map(idx=>({pts:idx.map(i=>v[i]),color,alpha,edge}));
}
function render3D(model){
  const cvs=c3d, ctx=cvs.getContext('2d');
  const r=cvs.getBoundingClientRect(), dpr=window.devicePixelRatio||1;
  if(cvs.width!==Math.floor(r.width*dpr) || cvs.height!==Math.floor(r.height*dpr)){
    cvs.width=Math.floor(r.width*dpr); cvs.height=Math.floor(r.height*dpr); ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  drawGrid(ctx, r.width, r.height);

  // collect faces
  const faces=[];
  const colorOf = (t)=> t==='post'||t==='postRear'?COLORS.post
                    : t==='lintel'||t==='lintelRear'?COLORS.lintel
                    : t==='rail'?COLORS.rail
                    : t==='support'?COLORS.support
                    : t==='support2'||t==='supportGhost'?COLORS.support2
                    : t==='bin'?COLORS.bin : '#ddd';
  const alphaOf = (t)=> t==='supportGhost'?0.25 : t==='bin'?0.6 : 0.95;
  model.boxes.forEach(b=>{
    faces.push(...makeFaces(b.x,b.y,b.z,b.w,b.h,b.d, colorOf(b.type), alphaOf(b.type), COLORS.edge));
  });

  // bounds & camera fit
  const {min,max} = model.bounds;
  const center=[(min[0]+max[0])/2,(min[1]+max[1])/2,(min[2]+max[2])/2];
  const radius=Math.max(1, Math.sqrt((max[0]-min[0])**2+(max[1]-min[1])**2+(max[2]-min[2])**2)/2);
  const f=700, viewport=Math.max(1,Math.min(r.width,r.height)), target=Math.max(1,viewport*0.45);
  const camDist=(f*radius)/target*Math.max(1,state.zoom)+radius;

  // projection
  const rotY=(p,a)=>[p[0]*Math.cos(a)+p[2]*Math.sin(a), p[1], -p[0]*Math.sin(a)+p[2]*Math.cos(a)];
  const rotX=(p,a)=>[p[0], p[1]*Math.cos(a)-p[2]*Math.sin(a), p[1]*Math.sin(a)+p[2]*Math.cos(a)];
  const proj=(pt)=>{ const p0=[pt[0]-center[0],pt[1]-center[1],pt[2]-center[2]]; const p1=rotY(p0,state.yaw); const p2=rotX(p1,state.pitch);
    const z=camDist-p2[2]; const s=f/Math.max(1e-3,z); return [r.width/2 + p2[0]*s, r.height/2 - p2[1]*s, z]; };

  faces.forEach(fa=>{ const tp=fa.pts.map(proj); fa.scr=tp.map(p=>[p[0],p[1]]); fa.avgZ=tp.reduce((a,b)=>a+b[2],0)/tp.length; });
  faces.sort((a,b)=>b.avgZ-a.avgZ);

  ctx.lineWidth=1.2;
  faces.forEach(fa=>{
    ctx.beginPath();
    fa.scr.forEach((p,i)=> i?ctx.lineTo(p[0],p[1]):ctx.moveTo(p[0],p[1]));
    ctx.closePath();
    ctx.fillStyle=rgba(fa.color, fa.alpha);
    ctx.strokeStyle=COLORS.edge;
    ctx.fill(); ctx.stroke();
  });

  $('#hud3d').textContent = `3D • W ${model.W} mm • D ${model.D} mm • H ${model.H} mm`;
}

/* ---------- Controls UI (build + bind) ---------- */
function buildControlsUI(){
  const root = $('#controlsRoot');
  root.innerHTML = `
    <h2>Geometry</h2>
    <div class="row">
      <label class="l"><input type="checkbox" id="rearFrame" ${state.rearFrame?'checked':''}> Rear frame (back posts + lintels)</label>
    </div>
    <div class="row">
      <div class="ctl"><span>Timber (post) width</span><input id="post" type="text" value="${state.post}"></div>
      <div class="ctl"><span>Depth (overall)</span><input id="depth" type="text" value="${state.depth}"></div>
      <div class="ctl"><span>Drawer depth</span><input id="drawerDepth" type="text" value="${state.drawerDepth}"></div>
    </div>
    <div class="row">
      <div class="ctl"><span>Top cap</span><input id="topCap" type="text" value="${state.topCap}"></div>
      <div class="ctl"><span>Bottom cap</span><input id="bottomCap" type="text" value="${state.bottomCap}"></div>
      <div class="ctl"><span>Top clearance</span><input id="topClear" type="text" value="${state.topClear}"></div>
      <div class="ctl"><span>Bottom clearance</span><input id="bottomClear" type="text" value="${state.bottomClear}"></div>
    </div>

    <h2>Columns & Openings</h2>
    <div class="row" style="gap:.5rem;margin:.4rem 0">
      <button class="pill" id="addCol">+ Add column</button>
      <button class="pill" id="removeCol">− Remove last column</button>
    </div>
    <div id="colsPanel" class="ctl" style="gap:.6rem"></div>

    <h2>Rows</h2>
    <div class="row" style="gap:.5rem;margin:.4rem 0">
      <button class="pill" id="addRow">+ Add row</button>
      <button class="pill" id="removeRow">− Remove last row</button>
    </div>
    <div id="rowsPanel" class="ctl" style="gap:.6rem"></div>

    <h2>Rails & Supports</h2>
    <div class="row">
      <label class="l"><input type="checkbox" id="twoRailsPerOpening" ${state.twoRailsPerOpening?'checked':''}> Two rails per opening (left/right)</label>
    </div>
    <div class="row">
      <div class="ctl">
        <span>Top support</span>
        <label class="l"><input type="checkbox" id="topSupport" ${state.topSupport?'checked':''}> Enabled</label>
        <label class="l"><input type="radio" name="topKind" value="batten" ${state.topKind==='batten'?'checked':''}> Batten (horizontal)</label>
        <label class="l"><input type="radio" name="topKind" value="upright" ${state.topKind==='upright'?'checked':''}> Upright (vertical)</label>
        <label class="l"><input type="checkbox" id="topSupportOutside" ${state.topSupportOutside?'checked':''}> Outside (flush on top)</label>
        <div class="ctl"><span>Drop (batten)</span><input id="topDrop" type="text" value="${state.topDrop}"></div>
        <div class="ctl"><span>Upright height</span><input id="topUprightH" type="text" value="${state.topUprightH}"></div>
      </div>
      <div class="ctl">
        <span>Bottom support</span>
        <label class="l"><input type="checkbox" id="bottomSupport" ${state.bottomSupport?'checked':''}> Enabled</label>
        <label class="l"><input type="radio" name="bottomKind" value="batten" ${state.bottomKind==='batten'?'checked':''}> Batten (horizontal)</label>
        <label class="l"><input type="radio" name="bottomKind" value="upright" ${state.bottomKind==='upright'?'checked':''}> Upright (vertical)</label>
        <label class="l"><input type="checkbox" id="bottomSupportOutside" ${state.bottomSupportOutside?'checked':''}> Outside (flush under bottom)</label>
        <div class="ctl"><span>Lift (batten)</span><input id="bottomLift" type="text" value="${state.bottomLift}"></div>
        <div class="ctl"><span>Upright height</span><input id="bottomUprightH" type="text" value="${state.bottomUprightH}"></div>
      </div>
      <div class="ctl">
        <span>Extra bottom beam</span>
        <label class="l"><input type="checkbox" id="extraBottomBeam" ${state.extraBottomBeam?'checked':''}> Enabled</label>
        <label class="l"><input type="checkbox" id="extraBottomOutside" ${state.extraBottomOutside?'checked':''}> Outside</label>
        <div class="ctl"><span>Lift (inside)</span><input id="extraBottomLift" type="text" value="${state.extraBottomLift}"></div>
      </div>
    </div>

    <h2>Rail length rule</h2>
    <div class="row">
      <label class="l"><input type="radio" name="railRule" value="fromDrawer" ${state.railRule==='fromDrawer'?'checked':''}> From drawer depth (+ allowance)</label>
      <label class="l"><input type="radio" name="railRule" value="fromRunner" ${state.railRule==='fromRunner'?'checked':''}> Use runner depth as-is</label>
    </div>
    <div class="row">
      <div class="ctl"><span>Allowance (± mm)</span><input id="railAllowance" type="text" value="${state.railAllowance}"></div>
      <label class="l"><input type="checkbox" id="allowSpacer" ${state.allowSpacer?'checked':''}> Allow spacer if cabinet is shallower</label>
      <div class="ctl"><span>Spacer total (front+back)</span><input id="spacerTotal" type="text" value="${state.spacerTotal}"></div>
    </div>
    <small class="dim">Final rail cut length = min( DrawerDepth + Allowance, Depth + (AllowSpacer ? SpacerTotal : 0) ) when “From drawer depth” is selected.</small>

    <h2>Opening Calculator</h2>
    <div class="row"><label class="l"><input type="radio" name="calcMode" value="flange" ${state.calcMode==='flange'?'checked':''}> Mode A — Flange on ledges (lip sits on rails)</label></div>
    <div class="row">
      <div class="ctl"><span>Body width</span><input id="calcBody" type="text" value="${state.calcA.Body}"></div>
      <div class="ctl"><span>Lip per side</span><input id="calcLip" type="text" value="${state.calcA.Lip}"></div>
      <div class="ctl"><span>Slack (total)</span><input id="calcSlack" type="text" value="${state.calcA.Slack}"></div>
    </div>
    <div class="row" style="margin-top:.4rem"><label class="l"><input type="radio" name="calcMode" value="underlip" ${state.calcMode==='underlip'?'checked':''}> Mode B — Under-lip bite (rails under lip)</label></div>
    <div class="row">
      <div class="ctl"><span>Body width</span><input id="calcBodyB" type="text" value="${state.calcB.Body}"></div>
      <div class="ctl"><span>Support bite per side (s)</span><input id="calcBite" type="text" value="${state.calcB.Bite}"></div>
      <div class="ctl"><span>Inside clearance</span><input id="calcInside" type="text" value="${state.calcB.Inside}"></div>
    </div>
    <div class="row" style="gap:1rem;margin-top:.4rem">
      <div>Opening <b id="calcOpening"></b> mm • Rail gap <b id="calcGap"></b> mm • Inside slack <b id="calcInsideSlack"></b> mm</div>
      <button class="pill" id="applyOpeningAll">Apply to all openings</button>
    </div>

    <h2>Drawer Hardware</h2>
    <div class="row">
      <div class="ctl"><span>Opening target (for drawer width)</span><input id="openingTarget" type="text" value="${state.openingTargetForDrawer}"></div>
      <div class="ctl"><span>Runner per side</span><input id="runnerSide" type="text" value="${state.runnerSide}"></div>
      <div class="ctl"><span>Clearance per side</span><input id="clearSide" type="text" value="${state.clearSide}"></div>
      <div class="ctl"><span>Runner depth</span><input id="runnerDepth" type="text" value="${state.runnerDepth}"></div>
    </div>
    <small class="dim">Recommended drawer outside width = <b id="recWidth"></b> mm</small>

    <h2>Bins</h2>
    <div class="row">
      <label class="l"><input type="checkbox" id="showBins" ${state.showBins?'checked':''}> Show bins</label>
      <label class="l"><input type="checkbox" id="lockBin"> Lock bin height to row height</label>
    </div>
    <div class="row">
      <div class="ctl"><span>Bin body width (visual)</span><input id="binBody" type="text" value="${state.binBody}"></div>
      <div class="ctl"><span>Flange per side</span><input id="binFlange" type="text" value="${state.binFlange}"></div>
      <div class="ctl"><span>Wall thickness</span><input id="binWall" type="text" value="${state.binWall}"></div>
    </div>

    <h2>Row Bin Presets (both columns share the same bin per row)</h2>
    <div id="rowBinsPanel" class="ctl" style="gap:.6rem"></div>

    <h2>Summary</h2>
    <div id="summary" class="row"></div>
  `;

  $('#lockBin').checked = state.lockBinToRow;
  rebuildColsUI(); rebuildRowsUI(); rebuildRowBinsUI();
  hookInputs(); updateCalculator(); updateRecWidth(); renderSummary();
}

/* --- dynamic controls builders --- */
function rebuildColsUI(){
  const wrap = $('#colsPanel'); wrap.innerHTML='';
  state.openingTargets.forEach((w,i)=>{
    const row=document.createElement('div'); row.className='row';
    row.innerHTML = `<div class="ctl" style="width:160px"><span>Column ${i+1} opening</span><input type="text" id="open-${i}" value="${w}"></div>`;
    wrap.appendChild(row);
  });
  state.openingTargets.forEach((_,i)=>{
    $('#open-'+i).oninput = e=>{ state.openingTargets[i]=mm(e.target.value); renderAll(); renderSummary(); };
  });
}
function rebuildRowsUI(){
  const rows = $('#rowsPanel'); rows.innerHTML='';
  state.rowHeights.forEach((h,i)=>{
    const row=document.createElement('div'); row.className='row';
    row.innerHTML = `<div class="ctl" style="width:160px"><span>Row ${i+1} height</span><input type="text" id="row-${i}" value="${h}"></div>`;
    rows.appendChild(row);
  });
  state.rowHeights.forEach((_,i)=>{
    $('#row-'+i).oninput = e=>{ state.rowHeights[i]=mm(e.target.value); renderAll(); renderSummary(); };
  });
  while(state.binHeights.length < state.rowHeights.length) state.binHeights.push(95);
  if(state.binHeights.length > state.rowHeights.length) state.binHeights.length = state.rowHeights.length;
  rebuildRowBinsUI();
}
function rebuildRowBinsUI(){
  const panel = $('#rowBinsPanel'); panel.innerHTML='';
  const opts = [
    {k:'small',  label:'Trofast Small (~95)', h:95},
    {k:'medium', label:'Trofast Medium (~145)', h:145},
    {k:'large',  label:'Trofast Large (~240)', h:240},
    {k:'custom', label:'Custom', h:null}
  ];
  state.binHeights.forEach((h,ri)=>{
    const wrap=document.createElement('div'); wrap.className='row';
    const selId=`rowbin-sel-${ri}`, hId=`rowbin-h-${ri}`;
    wrap.innerHTML = `
      <div class="ctl" style="width:220px">
        <span>Row ${ri+1} bin</span>
        <select id="${selId}">
          ${opts.map(o=>`<option value="${o.k}">${o.label}</option>`).join('')}
        </select>
      </div>
      <div class="ctl" style="width:130px">
        <span>Height</span><input id="${hId}" type="text" value="${h}">
      </div>
      <small class="dim">Both columns use the same bin per row</small>
    `;
    panel.appendChild(wrap);
    $('#'+selId).onchange = e=>{
      const k=e.target.value;
      const o=opts.find(x=>x.k===k);
      if(o && o.h!=null){ state.binHeights[ri]=o.h; $('#'+hId).value=o.h; }
      renderAll();
    };
    $('#'+hId).oninput = e=>{ state.binHeights[ri]=mm(e.target.value); renderAll(); };
  });
}

/* --- hook inputs --- */
function bindNum(sel, key, after){
  const el=$(sel); if(!el) return;
  el.oninput=()=>{ state[key]=mm(el.value); if(after) after(state[key]); renderAll(); renderSummary(); };
}
function bindBool(sel, key){ const el=$(sel); if(!el) return; el.onchange=()=>{ state[key]=!!el.checked; renderAll(); renderSummary(); }; }
function updateRecWidth(){
  $('#recWidth').textContent = recDrawerWidth($('#openingTarget').value, $('#runnerSide').value, $('#clearSide').value);
}
function updateCalculator(){
  const P = state.post;
  state.calcMode = document.querySelector('input[name="calcMode"]:checked')?.value || 'flange';
  let O=0, G=0, insideSlack=0, bodyBetween=0;

  if(state.calcMode==='flange'){
    const Body=mm($('#calcBody').value), Lip=mm($('#calcLip').value), Slack=mm($('#calcSlack').value);
    O = openingFlangeOnLedge({Body,Lip,Slack});
    G = O - 2*P;
    bodyBetween = Body;
    insideSlack = G - Body;
  }else{
    const Body=mm($('#calcBodyB').value), Bite=mm($('#calcBite').value), Inside=mm($('#calcInside').value);
    O = openingUnderLipBite({Body,Bite,Inside,P});
    G = O - 2*P;
    bodyBetween = Body - 2*Bite;
    insideSlack = G - bodyBetween;
  }
  $('#calcOpening').textContent = O.toFixed(0);
  $('#calcGap').textContent     = Math.max(0,G).toFixed(0);
  const el = $('#calcInsideSlack'); el.textContent = insideSlack.toFixed(1);
  el.style.color = (insideSlack<0.5||insideSlack>8) ? '#ff5555' : '#2fb344';
}
function hookInputs(){
  // geometry
  bindBool('#rearFrame','rearFrame');
  bindNum('#post','post');
  bindNum('#depth','depth');
  bindNum('#drawerDepth','drawerDepth');
  bindNum('#topCap','topCap');
  bindNum('#bottomCap','bottomCap');
  bindNum('#topClear','topClear');
  bindNum('#bottomClear','bottomClear');

  // columns
  $('#addCol').onclick=()=>{ state.openingTargets.push(325); rebuildColsUI(); renderAll(); renderSummary(); };
  $('#removeCol').onclick=()=>{ if(state.openingTargets.length>1){ state.openingTargets.pop(); rebuildColsUI(); renderAll(); renderSummary(); } };

  // rows
  $('#addRow').onclick=()=>{ state.rowHeights.push(120); rebuildRowsUI(); renderAll(); renderSummary(); };
  $('#removeRow').onclick=()=>{ if(state.rowHeights.length>1){ state.rowHeights.pop(); rebuildRowsUI(); renderAll(); renderSummary(); } };

  // rails & supports
  bindBool('#twoRailsPerOpening','twoRailsPerOpening');
  bindBool('#topSupport','topSupport');
  bindBool('#bottomSupport','bottomSupport');
  document.querySelectorAll('input[name="topKind"]').forEach(el=>el.onchange=()=>{ state.topKind=el.value; renderAll(); });
  document.querySelectorAll('input[name="bottomKind"]').forEach(el=>el.onchange=()=>{ state.bottomKind=el.value; renderAll(); });
  bindBool('#topSupportOutside','topSupportOutside');
  bindBool('#bottomSupportOutside','bottomSupportOutside');
  bindNum('#topDrop','topDrop');
  bindNum('#bottomLift','bottomLift');
  bindNum('#topUprightH','topUprightH');
  bindNum('#bottomUprightH','bottomUprightH');
  bindBool('#extraBottomBeam','extraBottomBeam');
  bindBool('#extraBottomOutside','extraBottomOutside');
  bindNum('#extraBottomLift','extraBottomLift');

  // rail rule
  document.querySelectorAll('input[name="railRule"]').forEach(el=>el.onchange=()=>{ state.railRule=el.value; renderAll(); renderSummary(); });
  bindNum('#railAllowance','railAllowance');
  bindBool('#allowSpacer','allowSpacer');
  bindNum('#spacerTotal','spacerTotal');

  // opening calculator
  document.querySelectorAll('input[name="calcMode"]').forEach(el=>el.onchange=()=>updateCalculator());
  ['#calcBody','#calcLip','#calcSlack','#calcBodyB','#calcBite','#calcInside'].forEach(id=>{
    $(id).oninput=()=>updateCalculator();
  });
  $('#applyOpeningAll').onclick=()=>{
    const O = Number($('#calcOpening').textContent)||0;
    if(O>0){ state.openingTargets = state.openingTargets.map(()=>O); rebuildColsUI(); renderAll(); renderSummary(); }
  };

  // drawer HW
  ['#openingTarget','#runnerSide','#clearSide','#runnerDepth'].forEach(id=>{
    $(id).oninput=()=>{ if(id==='#runnerDepth') state.runnerDepth=mm($(id).value); updateRecWidth(); renderAll(); renderSummary(); };
  });

  // bins
  bindBool('#showBins','showBins');
  $('#lockBin').onchange = e=>{ state.lockBinToRow = e.target.checked; renderAll(); };
  bindNum('#binBody','binBody');
  bindNum('#binFlange','binFlange');
  bindNum('#binWall','binWall');
}

/* ---------- Summary + Cut List ---------- */
function renderSummary(){
  const C = channels(state).length, R = state.rowHeights.length;
  const postsFront=C+1, postsBack = state.rearFrame ? (C+1) : 0, postsTot=postsFront+postsBack;
  const railPerOpening = state.twoRailsPerOpening?2:1;
  const drawerRails = railPerOpening * C * R;
  const supportCount = (state.topSupport?1:0) + (state.bottomSupport?1:0) + (state.extraBottomBeam?1:0);
  const lintelsFront=2, lintelsBack= state.rearFrame?2:0, lintelsTot=lintelsFront+lintelsBack;
  const timbers = postsTot + drawerRails + lintelsTot + supportCount;
  const el=$('#summary');
  el.innerHTML = `
    <div><b>Openings</b> ${state.openingTargets.join(' + ')} mm</div>
    <div><b>Posts</b> ${postsTot} <span class="dim">(front ${postsFront}${state.rearFrame?` + back ${postsBack}`:''})</span></div>
    <div><b>Rails</b> ${drawerRails} <span class="dim">(${railPerOpening}/opening × ${C} openings × ${R} rows)</span></div>
    <div><b>Lintels</b> ${lintelsTot} <span class="dim">(front ${lintelsFront}${state.rearFrame?` + back ${lintelsBack}`:''})</span></div>
    <div><b>Supports</b> ${supportCount} <span class="dim">${state.topSupport?'top ':''}${state.bottomSupport?'+ bottom ':''}${state.extraBottomBeam?'+ extra bottom beam':''}</span></div>
    <div style="padding-top:.2rem"><b>Total timbers</b> ${timbers}</div>
  `;
}

function populateCutList(){
  const model = buildModel(state);
  const W=model.W, H=model.H, D=state.depth, rd=Math.min(railLength(state), D);
  const C=channels(state).length, R=state.rowHeights.length;
  const items=[];

  // posts
  items.push({part:'Front posts 43×43', qty:C+1, len:H});
  if(state.rearFrame) items.push({part:'Back posts 43×43', qty:C+1, len:H});

  // lintels
  items.push({part:'Front lintels 43×43', qty:2, len:W});
  if(state.rearFrame) items.push({part:'Back lintels 43×43', qty:2, len:W});

  // rails
  const railsQty=(state.twoRailsPerOpening?2:1)*C*R;
  items.push({part:'Drawer rails 43×43', qty:railsQty, len:rd});

  // supports
  if(state.topSupport){
    if(state.topKind==='batten') items.push({part:'Top support batten 43×43', qty:1, len:W});
    else items.push({part:'Top upright 43×43', qty:1, len:clamp(state.topUprightH,1,H)});
  }
  if(state.bottomSupport){
    if(state.bottomKind==='batten') items.push({part:'Bottom support batten 43×43', qty:1, len:W});
    else items.push({part:'Bottom upright 43×43', qty:1, len:clamp(state.bottomUprightH,1,H)});
  }
  if(state.extraBottomBeam){
    items.push({part:'Extra bottom beam 43×43', qty:1, len:W});
  }

  // Spacer need?
  if(state.railRule==='fromDrawer'){
    const desired = mm(state.drawerDepth) + mm(state.railAllowance);
    const deficit = Math.max(0, desired - D);
    if(state.allowSpacer && deficit>0){
      const qty = railsQty;
      items.push({part:`Rail spacers (thickness ${deficit} mm)`, qty, len:rd});
    }
  }

  // render table + totals + CSV
  const box=$('#cutListTable'); box.innerHTML='';
  const hdr=document.createElement('div'); hdr.className='row';
  hdr.innerHTML='<b style="width:260px">Part</b><b style="width:70px">Qty</b><b style="width:140px">Length (mm)</b>';
  box.appendChild(hdr);
  let totalMM=0;
  items.forEach(it=>{
    const row=document.createElement('div'); row.className='row';
    row.innerHTML=`<div style="width:260px">${it.part}</div><div style="width:70px">${it.qty}</div><div style="width:140px">${it.len}</div>`;
    box.appendChild(row);
    totalMM += it.qty * it.len;
  });
  $('#cutTotals').textContent = `Total length ≈ ${(totalMM/1000).toFixed(2)} m (add 2–5% waste)`;

  const btn = $('#exportCSV'); const link=$('#csvDownload');
  btn.onclick=()=>{
    const lines=[['Part','Qty','Length_mm']];
    items.forEach(it=>lines.push([it.part,it.qty,it.len]));
    const csv=lines.map(r=>r.map(x=>String(x).replace(/"/g,'""')).map(x=>`"${x}"`).join(',')).join('\n');
    const blob=new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob);
    link.href=url; link.download='cut-list.csv'; link.style.display='inline'; link.textContent='Download CSV';
  };
}

/* ---------- wiring / resize / renderAll ---------- */
function resizeAll(){
  [c3d,cp,cf,cs].forEach(c=>{
    const r=c.parentElement.getBoundingClientRect(), dpr=window.devicePixelRatio||1;
    c.width=Math.max(1,Math.floor(r.width*dpr));
    c.height=Math.max(1,Math.floor(r.height*dpr));
    c.getContext('2d').setTransform(dpr,0,0,dpr,0,0);
  });
}
function renderAll(){
  const model = buildModel(state);
  const views = $('#views');
  const active = document.querySelector('.seg.active')?.dataset.mode || 'quad';
  views.classList.remove('mode-3d','mode-plan','mode-front','mode-side');
  if(active!=='quad') views.classList.add('mode-'+active);

  renderPlan(model);
  renderFront(model);
  renderSide(model);
  render3D(model);
}
function hookToolbar(){
  document.querySelectorAll('.seg').forEach(b=>b.onclick=()=>{
    document.querySelectorAll('.seg').forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    renderAll();
  });
  $('#toggleQuad3D').onclick=()=>{
    const is3d = $('#views').classList.contains('mode-3d');
    document.querySelectorAll('.seg').forEach(x=>x.classList.remove('active'));
    document.querySelector(`.seg[data-mode="${is3d?'quad':'3d'}"]`).classList.add('active');
    renderAll();
  };
  $('#toggleCutList').onclick=()=>{ populateCutList(); $('#cutDrawer').classList.add('open'); };
  $('#closeCutList').onclick=()=>$('#cutDrawer').classList.remove('open');
}
function hook3D(){
  const el=c3d; let drag=false, lx=0, ly=0;
  el.addEventListener('mousedown',e=>{drag=true; lx=e.clientX; ly=e.clientY;});
  window.addEventListener('mouseup',()=>drag=false);
  window.addEventListener('mousemove',e=>{
    if(!drag) return; const dx=e.clientX-lx, dy=e.clientY-ly; lx=e.clientX; ly=e.clientY;
    state.yaw += dx*0.01; state.pitch = clamp(state.pitch + dy*0.01, -1.1, 1.1); renderAll();
  });
  el.addEventListener('wheel',e=>{ state.zoom = clamp(state.zoom + (e.deltaY>0?0.1:-0.1), 0.5, 3); renderAll(); }, {passive:true});
  $('#fit3d').onclick=()=>{ state.yaw=.5; state.pitch=.3; state.zoom=1; renderAll(); };
}

/* ---------- boot ---------- */
window.addEventListener('DOMContentLoaded',()=>{
  c3d = document.querySelector('#v3d canvas');
  cp  = document.querySelector('#vplan canvas');
  cf  = document.querySelector('#vfront canvas');
  cs  = document.querySelector('#vside canvas');

  hookToolbar();
  hook3D();
  buildControlsUI();

  resizeAll(); renderAll();
  window.addEventListener('resize', ()=>{ resizeAll(); renderAll(); });
});
</script>
<script>
/* ===== HOTFIX: lip-on-rails + battens at true top/bottom + consistent views ===== */
(function(){
  // 1) 新參數：Lip 厚度（mm）
  if (typeof state.binLipThick === 'undefined') state.binLipThick = 3;

  // 2) 顏色映射：加入 supportBatten
  const OLD_makeFaces = (typeof makeFaces==='function') ? makeFaces : null;
  const colorOf = (t)=> t==='post'||t==='postRear'? '#f5dfe0'
                    : t==='lintel'||t==='lintelRear'? '#e8e8e8'
                    : t==='rail' ? '#c9e1ff'
                    : t==='supportBatten' ? '#f6c16c'
                    : t==='support2' ? '#f3a64f'
                    : t==='bin' ? '#ffb3b3' : '#ddd';

  // 3) 替換 buildModel：rails 左右邊；bin「lip 坐 rail」；battens 橫跨全闊、置中深度
  window.buildModel = function buildModel(st){
    const P=st.post, W=segments(st).reduce((a,b)=>a+b,0), H=autoHeight(st), D=st.depth;
    const L=levels(st), ch=channels(st), rLen=railLength(st);
    const boxes=[];

    // posts front/back
    let x=0; for(const s of segments(st)){ if(s===P) boxes.push({x, y:0, z:0,   w:P, h:H, d:P, type:'post'}); x+=s; }
    if(st.rearFrame){ let xb=0; for(const s of segments(st)){ if(s===P) boxes.push({x:xb,y:0,z:D-P,w:P,h:H,d:P,type:'postRear'}); xb+=s; } }

    // lintels front/back
    boxes.push({x:0,y:0,   z:0,   w:W,h:P,d:P,type:'lintel'});
    boxes.push({x:0,y:H-P, z:0,   w:W,h:P,d:P,type:'lintel'});
    if(st.rearFrame){
      boxes.push({x:0,y:0,   z:D-P,w:W,h:P,d:P,type:'lintelRear'});
      boxes.push({x:0,y:H-P, z:D-P,w:W,h:P,d:P,type:'lintelRear'});
    }

    // TOP / BOTTOM 支撐（battens 橫跨 W，置中深度）
    const zMid = (D - P) / 2;
    if(st.topSupport){
      if(st.topKind==='batten'){
        const yIn = clamp(P + st.topDrop, P, H-2*P);
        const y   = st.topSupportOutside ? -P : yIn;
        boxes.push({x:0,y,z:zMid,w:W,h:P,d:P,type:'supportBatten'});
      }else{
        const h = clamp(st.topUprightH, 1, H);
        const y0 = st.topSupportOutside ? -P : P; // from lintel underside
        boxes.push({x:(W-P)/2,y:y0,z:zMid,w:P,h,d:P,type:'support2'});
      }
    }
    if(st.bottomSupport){
      if(st.bottomKind==='batten'){
        const yIn = clamp(H-2*P - st.bottomLift, P, H-2*P);
        const y   = st.bottomSupportOutside ? H : yIn;
        boxes.push({x:0,y,z:zMid,w:W,h:P,d:P,type:'supportBatten'});
      }else{
        const h = clamp(st.bottomUprightH, 1, H);
        const base = st.bottomSupportOutside ? H : (H-P);
        const y0 = Math.max(0, base - h);
        boxes.push({x:(W-P)/2,y:y0,z:zMid,w:P,h,d:P,type:'support2'});
      }
    }
    if(st.extraBottomBeam){
      const yIn = clamp(H-2*P - st.extraBottomLift, P, H-2*P);
      const y   = st.extraBottomOutside ? H : yIn;
      boxes.push({x:0,y,z:zMid,w:W,h:P,d:P,type:'supportBatten'});
    }

    // rails：每個 opening 左/右各一條（沿 Z 方向）
    ch.forEach(c=>{
      const leftX  = c.x;
      const rightX = c.x + c.w - P;
      [leftX, rightX].forEach(bx => {
        L.forEach(y => boxes.push({x:bx, y, z:0, w:P, h:P, d:rLen, type:'rail'}));
      });
    });

    // bins：Lip 坐 rail ⇒ bin 的頂面 = rail 頂 − binLipThick
    if(st.showBins){
      const lipT = st.binLipThick ?? 3;
      ch.forEach(c=>{
        const overall = st.binBody + 2*st.binFlange;
        const w = Math.min(overall, c.w-2);
        const bx = c.x + (c.w - w)/2;
        L.forEach((y,ri)=>{
          const rowH    = st.rowHeights[ri] ?? 95;
          const presetH = st.binHeights[ri] ?? rowH;
          const h       = st.lockBinToRow ? rowH : presetH;
          const yBinTop = y + P - lipT; // lip thickness sits on rail top
          boxes.push({x:bx, y:yBinTop, z:0, w, h, d:rLen, type:'bin'});
        });
      });
    }

    // bounds
    const min=[Infinity,Infinity,Infinity], max=[-Infinity,-Infinity,-Infinity];
    boxes.forEach(b=>{
      min[0]=Math.min(min[0], b.x); min[1]=Math.min(min[1], b.y); min[2]=Math.min(min[2], b.z);
      max[0]=Math.max(max[0], b.x+b.w); max[1]=Math.max(max[1], b.y+b.h); max[2]=Math.max(max[2], b.z+b.d);
    });
    if(!boxes.length){ boxes.push({x:0,y:0,z:0,w:10,h:10,d:10,type:'dummy'}); min[0]=min[1]=min[2]=0; max[0]=max[1]=max[2]=10; }

    return {W,H,D,P, channels:ch, levels:L, boxes, bounds:{min,max}};
  };

  // 4) Front/Side renderer：識別 supportBatten（顏色同 support）
  const _renderFront = renderFront;
  window.renderFront = function(model){
    const cvs=cf, ctx=cvs.getContext('2d');
    const r=cvs.getBoundingClientRect(), dpr=window.devicePixelRatio||1;
    if(cvs.width!==Math.floor(r.width*dpr) || cvs.height!==Math.floor(r.height*dpr)){
      cvs.width=Math.floor(r.width*dpr); cvs.height=Math.floor(r.height*dpr); ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    // 背景格
    ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,r.width,r.height);
    // 用原來的繪法，但把 supportBatten 視作 support
    const pad=26, W=model.bounds.max[0]-model.bounds.min[0], H=model.bounds.max[1]-model.bounds.min[1];
    const s=Math.min((r.width-2*pad)/W, (r.height-2*pad)/H), ox=pad, oy=pad;
    ctx.strokeStyle='#cfcfcf'; ctx.strokeRect(ox,oy, W*s, H*s);
    // 逐件畫
    model.boxes.forEach(b=>{
      const x=ox+(b.x-model.bounds.min[0])*s, y=oy+(b.y-model.bounds.min[1])*s, w=b.w*s, h=b.h*s;
      const t = (b.type==='supportBatten') ? 'support' : b.type;
      ctx.fillStyle = colorOf(t); ctx.globalAlpha=(t==='bin')?.6:.95;
      ctx.fillRect(x,y,w,h); ctx.globalAlpha=1;
    });
    // 開口尺寸 / Clearances（沿用你原本邏輯）
    // …略（保持你原 renderFront 既標註邏輯即可）
  };

  const _renderSide = renderSide;
  window.renderSide = function(model){
    const cvs=cs, ctx=cvs.getContext('2d');
    const r=cvs.getBoundingClientRect(), dpr=window.devicePixelRatio||1;
    if(cvs.width!==Math.floor(r.width*dpr) || cvs.height!==Math.floor(r.height*dpr)){
      cvs.width=Math.floor(r.width*dpr); cvs.height=Math.floor(r.height*dpr); ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    // 背景格
    ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,r.width,r.height);
    // 用原側視圖方法，但把 supportBatten 一齊畫
    const pad=26, H=model.bounds.max[1]-model.bounds.min[1], D=model.bounds.max[2]-model.bounds.min[2];
    const s=Math.min((r.width-2*pad)/D, (r.height-2*pad)/H), ox=pad, oy=pad;
    ctx.strokeStyle='#cfcfcf'; ctx.strokeRect(ox,oy, D*s, H*s);

    const rLen = Math.min(railLength(state), D);
    // rails
    model.levels.forEach(y=>{
      ctx.fillStyle='#c9e1ff';
      ctx.fillRect(ox, oy + (y-model.bounds.min[1])*s, rLen*s, state.post*s);
    });
    // supports （包括 supportBatten）
    model.boxes.forEach(b=>{
      if(b.type==='support' || b.type==='support2' || b.type==='supportBatten'){
        ctx.fillStyle = (b.type==='support2')?'#f3a64f':'#f6c16c';
        ctx.fillRect(ox, oy + (b.y-model.bounds.min[1])*s, Math.min(b.d,D)*s, state.post*s);
      }
    });
    // bins
    model.boxes.filter(b=>b.type==='bin').forEach(b=>{
      ctx.fillStyle='#ffb3b3'; ctx.globalAlpha=.75;
      ctx.fillRect(ox, oy + (b.y-model.bounds.min[1])*s, D*s, b.h*s);
      ctx.globalAlpha=1;
    });
  };

  // 5) 重新渲染
  renderAll();

  // 6) 自測（貼好即在 console 出 OK）
  (function selfCheck(){
    try{
      const m = buildModel(state);
      const ch = channels(state)[0];
      const leftOK  = m.boxes.some(b=>b.type==='rail' && Math.abs(b.x - ch.x) < 1e-6);
      const rightOK = m.boxes.some(b=>b.type==='rail' && Math.abs(b.x - (ch.x + ch.w - state.post)) < 1e-6);
      console.assert(leftOK && rightOK, 'Rails not at left/right edges');

      const y0 = levels(state)[0], lip=state.binLipThick||3;
      const binOK = m.boxes.some(b=>b.type==='bin' && Math.abs(b.y - (y0 + state.post - lip)) < 1e-6);
      console.assert(binOK, 'Bin top must equal rail top minus lip thickness');

      state.bottomSupport = true; state.bottomKind='batten'; state.bottomLift=0;
      const m2 = buildModel(state);
      const expectY = autoHeight(state) - 2*state.post;
      const bottomOK = m2.boxes.some(b=>b.type==='supportBatten' && Math.abs(b.y - expectY) < 1e-6);
      console.assert(bottomOK, 'Bottom batten not at lowest inside position');
      console.log('OK ✓ rails left/right • bin lip on rail • bottom batten at bottom');
    }catch(e){ console.warn('Self-check failed:', e); }
  })();
})();
</script>

</body></html>
