<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rail + Bin Builder (mm) — single geometry</title>
<style>
  :root{
    --bg:#0b0b0b; --panel:#111; --grid:#1e1e1e; --ink:#e7e7e7;
    --ok:#3ac36a; --ng:#ff5c5c;
    --post:#f5dfe0; --lintel:#e8e8e8; --rail:#c9e1ff; --support:#f6c16c; --bin:rgba(255,179,179,.65);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:#0b0b0b;color:#e7e7e7;font:14px/1.25 system-ui,Segoe UI,Arial}
  h1,h2{margin:0 0 .5rem}
  small, .muted{color:#b7b7b7}
  button,input,select{font:inherit}
  .app{display:grid;grid-template-columns:1fr 360px;gap:8px;height:100%;padding:8px}
  .views{
    display:grid;
    grid-template-columns:1fr 1fr;
    grid-template-rows:1fr 1fr;
    grid-template-areas:
      "front 3d"
      "side plan";
    gap:6px;
    min-width:0;
    min-height:0
  }
  #pane-front{grid-area:front}
  #pane-3d{grid-area:3d}
  #pane-side{grid-area:side}
  #pane-plan{grid-area:plan}
  .pane{position:relative;background:var(--panel);border:1px solid #222;border-radius:6px;min-width:0;min-height:0;overflow:hidden}
  .pane canvas{width:100%;height:100%;display:block;touch-action:none}
  .hud{position:absolute;left:8px;top:8px;background:#0008;border-radius:4px;padding:4px 8px;font-size:12px}
  .toolbar{position:absolute;right:8px;top:8px;display:flex;gap:6px}
  .toolbar button{background:#0009;color:#fff;border:1px solid #333;border-radius:4px;padding:3px 6px;cursor:pointer}
  .sidebar{overflow:auto;background:#111;border:1px solid #222;border-radius:6px;padding:10px}
  .grp{border:1px solid #222;border-radius:8px;background:#141414;margin:10px 0;padding:10px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .ctl{display:flex;flex-direction:column;gap:4px;min-width:120px;flex:1}
  .ctl input[type="text"], .ctl input[type="number"], .ctl select{
    background:#0f0f0f;border:1px solid #2a2a2a;color:#e7e7e7;border-radius:6px;padding:6px 8px;min-width:100px
  }
  .badge{display:inline-block;background:#0009;border:1px solid #333;border-radius:4px;padding:2px 6px;margin-right:6px}
  .dim{position:absolute;right:8px;bottom:8px;font-size:11px;background:#0008;border-radius:4px;padding:2px 6px}
  .gridNote{position:absolute;left:8px;bottom:8px;font-size:11px;color:#c9c9c9}
  .ok{color:var(--ok)} .ng{color:var(--ng)}
  .split{display:grid;grid-template-columns:1fr 1fr;gap:6px}
  .cutlist{border-top:1px dashed #333;margin-top:8px;padding-top:8px}
  .hidden{display:none}
  /* single-view mode */
  .single .views{
    grid-template-columns:1fr;
    grid-template-rows:1fr;
    grid-template-areas:'main'
  }
  .single .views #pane-3d,
  .single .views #pane-front,
  .single .views #pane-side,
  .single .views #pane-plan{grid-area:main}
  .single .views .pane:not(.active){display:none}
</style>
</head>
<body>
  <div class="app" id="appRoot">
    <!-- ===== Views area ===== -->
    <div class="views" id="viewsWrap">
      <!-- 3D -->
      <div class="pane active" id="pane-3d">
        <canvas id="c3d"></canvas>
        <div class="hud">3D</div>
        <div class="dim" id="dim3d"></div>
        <div class="gridNote">Drag to orbit • Scroll to zoom • Double-click to reset</div>
        <div class="toolbar">
          <button class="btn tbView" data-view="3d">⤢</button>
          <button class="btn" id="tbFit">Fit</button>
          <button class="btn" id="tbPlus">+</button>
          <button class="btn" id="tbMinus">−</button>
          <button class="btn" id="tbReset">Reset</button>
        </div>
      </div>

      <!-- FRONT -->
      <div class="pane" id="pane-front">
        <canvas id="cfront"></canvas>
        <div class="hud">FRONT / Elevation (X×Y)</div>
        <div class="dim" id="dimFront"></div>
        <div class="toolbar"><button class="btn tbView" data-view="front">⤢</button></div>
      </div>

      <!-- SIDE -->
      <div class="pane" id="pane-side">
        <canvas id="cside"></canvas>
        <div class="hud">SIDE / Elevation (Z×Y)</div>
        <div class="dim" id="dimSide"></div>
        <div class="toolbar"><button class="btn tbView" data-view="side">⤢</button></div>
      </div>

      <!-- PLAN -->
      <div class="pane" id="pane-plan">
        <canvas id="cplan"></canvas>
        <div class="hud">TOP / Plan (X×Z)</div>
        <div class="dim" id="dimPlan"></div>
        <div class="toolbar"><button class="btn tbView" data-view="plan">⤢</button></div>
      </div>
    </div>

    <!-- ===== Sidebar / Controls ===== -->
    <div class="sidebar" id="controls">
      <h1>Rail + Drawer / Bin Builder (mm)</h1>

      <div class="grp">
        <div class="row">
          <div class="ctl">
            <label>View mode</label>
            <div class="row">
              <button class="btn" id="vmQuad">Quad</button>
              <button class="btn" id="vm3d">3D</button>
              <button class="btn" id="vmPlan">Plan</button>
              <button class="btn" id="vmFront">Front</button>
              <button class="btn" id="vmSide">Side</button>
            </div>
          </div>
          <div class="ctl">
            <label>Panels</label>
            <div class="row">
              <button class="btn" id="toggleCutlist">Cut List ▢</button>
              <button class="btn" id="fit">Fit view</button>
            </div>
          </div>
        </div>
        <small class="muted">Single geometry drives all views — no duplication.</small>
      </div>

      <div class="grp">
        <h2>Frame</h2>
        <div class="row">
          <div class="ctl"><label>Height (manual)</label><input id="height" value="926" /></div>
          <div class="ctl"><label><input id="autoHeight" type="checkbox" checked /> Auto height</label></div>
          <div class="ctl"><label>Depth (overall)</label><input id="depth" value="420" /></div>
          <div class="ctl"><label>Runner depth (usable)</label><input id="runnerDepth" value="420" /></div>
          <div class="ctl"><label>Post size (square)</label><input id="post" value="43" /></div>
          <div class="ctl"><label><input id="rearFrame" type="checkbox" checked /> Rear frame (back posts + lintels)</label></div>
        </div>
      </div>

      <div class="grp">
        <h2>Columns &amp; Openings</h2>
        <div class="ctl">
          <label>Pattern (accepts “283mm”; rounds up)</label>
          <input id="patternText" value="43,283,43,43,283,43,43" />
          <div class="muted">Segments = [post, open1, post, open2, …, post]</div>
        </div>
        <div class="row">
          <button class="btn" id="addCol">+ Add column</button>
          <button class="btn" id="remCol">− Remove last</button>
        </div>
        <div class="muted">Openings: <span id="openingsView" class="badge"></span></div>
      </div>

      <div class="grp">
        <h2>Rows (per-row)</h2>
        <div id="rows"></div>
        <div class="row">
          <button class="btn" id="addRow">+ Add row</button>
          <button class="btn" id="remRow">− Remove last</button>
        </div>
      </div>

      <div class="grp">
        <h2>Global Clearances</h2>
        <div class="row">
          <div class="ctl"><label>Top clearance</label><input id="topClear" value="10" /></div>
          <div class="ctl"><label>Bottom clearance</label><input id="bottomClear" value="10" /></div>
          <div class="ctl"><label><input id="bottomRowRails" type="checkbox" /> Bottom row has rails</label></div>
        </div>
      </div>

      <div class="grp">
        <h2>Rails</h2>
        <div class="ctl">
          <label>Placement</label>
          <select id="railMode">
            <option value="edges" selected>Edges (left & right)</option>
            <option value="centered">Centered (single)</option>
          </select>
        </div>
      </div>

      <div class="grp">
        <h2>Supports</h2>
        <div class="row">
          <div class="ctl"><label><input id="topSupport" type="checkbox" checked /> Top support</label></div>
          <div class="ctl">
            <label>Top orientation</label>
            <select id="topOrient"><option value="X" selected>Across width</option><option value="Z">Front-to-back</option></select>
          </div>
          <div class="ctl"><label>Top drop (mm)</label><input id="topDrop" value="0" /></div>
          <div class="ctl"><label>Top size (mm)</label><input id="topSize" value="43" /></div>
        </div>
        <div class="row">
          <div class="ctl"><label><input id="bottomSupport" type="checkbox" checked /> Bottom support</label></div>
          <div class="ctl">
            <label>Bottom orientation</label>
            <select id="bottomOrient"><option value="X" selected>Across width</option><option value="Z">Front-to-back</option></select>
          </div>
          <div class="ctl"><label>Bottom lift (mm)</label><input id="bottomLift" value="8" /></div>
          <div class="ctl"><label>Bottom size (mm)</label><input id="bottomSize" value="43" /></div>
        </div>
        <div class="ctl"><label><input id="extraBottomBeam" type="checkbox" /> Extra bottom beam</label></div>
      </div>

      <div class="grp">
        <h2>Bin / Opening helper</h2>
        <div class="row">
          <div class="ctl"><label>Bin body width (outer)</label><input id="binBody" value="283" /></div>
          <div class="ctl"><label>Lip overhang per side</label><input id="binFlange" value="9.5" /></div>
          <div class="ctl"><label>Lip thickness</label><input id="binLip" value="9" /></div>
          <div class="ctl"><label>Total slack (both sides)</label><input id="binSlack" value="6" /></div>
          <div class="ctl"><label>Default bin height (visual)</label><input id="binHeightDefault" value="95" /></div>
          <div class="ctl"><label><input id="showBins" type="checkbox" checked /> Show bins</label></div>
        </div>
        <div class="row">
          <button class="btn" id="applyOpening">Apply suggested opening to all columns</button>
          <span id="suggest" class="badge">Suggested opening: …</span>
        </div>
      </div>

      <div class="grp">
        <h2>Summary</h2>
        <div id="summary"></div>
        <div class="cutlist hidden" id="cutlist"></div>
      </div>

      <div class="grp">
        <h2>Tests</h2>
        <div id="tests"></div>
      </div>
    </div>
  </div>
<script>
/* =====================
   Utilities & palette
===================== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,Number(v??0)));
const mm=v=>Number(v||0);
const COLORS={ post:'#f5dfe0', lintel:'#e8e8e8', rail:'#c9e1ff', support:'#f6c16c', bin:'rgba(255,179,179,.65)', line:'#cfcfcf', dash:'#d8a7ad' };
COLORS.supportBatten = COLORS.support;
function rgba(hex,a){const c=hex.replace('#','');const r=parseInt(c.slice(0,2),16),g=parseInt(c.slice(2,4),16),b=parseInt(c.slice(4,6),16);return `rgba(${r},${g},${b},${a})`;}

/* =====================
   State (S)
===================== */
const S = {
  // Frame
  height: 926, autoHeight:true,
  depth: 420, runnerDepth: 420, post: 43, rearFrame: true,

  // Pattern text (user enters posts + openings). We normalize (no double posts).
  patternText: '43,283,43,43,283,43,43',

  // Rows (per-row)
  rows: [ {height:120,gap:10,overhang:0}, {height:120,gap:10,overhang:0}, {height:120,gap:10,overhang:0}, {height:120,gap:10,overhang:0} ],
  topClear:10, bottomClear:10, bottomRowRails:false,

  // Rails & supports
  railMode:'edges', // 'edges' | 'centered'
  topSupport:true, topOrient:'X', topDrop:0, topSize:43,
  bottomSupport:true, bottomOrient:'X', bottomLift:8, bottomSize:43,
  extraBottomBeam:false,

  // Bin / opening helper (bins sit on rails by lip)
  binBody:283, binFlange:9.5, binLip:9, binSlack:6,
  binHeightDefault:95, showBins:true,

  // UI state
  openingTarget:283,
  viewMode:'quad', // quad | 3d | plan | front | side
  showCutList:false
};

let M;

/* =====================
   Parsing & geometry
===================== */
// Accept user text like "283" or "283mm," and return an array of millimetres
// (all values rounded UP). If no valid numbers are found a safe default
// pattern is returned.
function parseList(txt){
  const re=/\b(\d+(?:\.\d+)?)\s*(?:mm)?\b/gi;
  const out=[]; let m;
  const str=String(txt);
  while((m=re.exec(str))){
    const n=Math.ceil(parseFloat(m[1]));
    if(Number.isFinite(n) && n>0) out.push(n);
  }
  return out.length? out : [43,283,43,43,283,43,43];
}
// Normalize an array of segments so the pattern is always
// [post, open1, post, open2, …, post]. Duplicate posts are collapsed.
function normalizeSegments(arr, post){
  const seg = Array.isArray(arr)? arr.slice() : [];
  if(seg[0] !== post) seg.unshift(post);
  if(seg[seg.length-1] !== post) seg.push(post);
  const out=[]; let lastWasPost=false;
  for(const n of seg){
    const isPost = n===post;
    if(isPost && lastWasPost) continue; // collapse duplicates
    out.push(n); lastWasPost=isPost;
  }
  if(out.length<3) out.splice(1,0,283); // ensure at least one opening
  return out;
}
function segments(){ return normalizeSegments(parseList(S.patternText), S.post); }
// Convert a normalized segment list into channel definitions {x,w}
function channels(){
  const seg = segments(); const P=S.post; let x=0; const out=[];
  for(const s of seg){
    if(s!==P) out.push({x, w:s});
    x += s;
  }
  return out;
}
function railXPositions(ch){
  if(S.railMode==='centered') return [ch.x + (ch.w - S.post)/2];
  return [ch.x, ch.x + ch.w - S.post];
}
let rowOverflow=false;
function computeLevels(){
  const P=S.post;
  let y=P + mm(S.bottomClear);
  const out=[];
  rowOverflow=false;
  for(const r of S.rows){
    if(!S.autoHeight && y > S.height - P){
      rowOverflow=true;
      break;
    }
    out.push(clamp(y,0,(S.autoHeight?1e9:S.height)-P));
    // Height of row + lintel + gap above that row
    y += mm(r.height) + P + mm(r.gap);
  }
  return out;
}
function autoHeightFromRows(){
  // Total height = caps + lintels + row heights (+ gaps)
  const P=S.post; // lintel thickness
  const lintels = P * (S.rows.length + 1); // one at bottom, one between each row, one at top
  const heights = S.rows.reduce((a,r)=>a + mm(r.height),0);
  const gaps    = S.rows.reduce((a,r)=>a + mm(r.gap),0);
  return lintels + mm(S.bottomClear) + mm(S.topClear) + heights + gaps;
}

/* =====================
   Model builder (single source of truth)
   M = { W,H,D,P, channels, levels, boxes[], bounds }
===================== */
function buildModel(){
  const P=S.post, ch=channels(), L=computeLevels(), W=segments().reduce((a,b)=>a+b,0);
  const H=S.autoHeight?autoHeightFromRows():S.height, D=S.depth, R=Math.min(S.runnerDepth, S.depth);
  const M={W,H,D,P,channels:ch,levels:L,rowOverflow,boxes:[]};

  // Posts (front)
  let x=0; for(const s of segments()){ if(s===P) M.boxes.push({type:'post',x,y:0,z:0,w:P,h:H,d:P}); x+=s; }
  // Posts (rear)
  if(S.rearFrame){ let xb=0; for(const s of segments()){ if(s===P) M.boxes.push({type:'post',x:xb,y:0,z:D-P,w:P,h:H,d:P}); xb+=s; } }

  // Lintels
  M.boxes.push({type:'lintel',x:0,y:0,z:0,w:W,h:P,d:P});
  M.boxes.push({type:'lintel',x:0,y:H-P,z:0,w:W,h:P,d:P});
  if(S.rearFrame){
    M.boxes.push({type:'lintel',x:0,y:0,z:D-P,w:W,h:P,d:P});
    M.boxes.push({type:'lintel',x:0,y:H-P,z:D-P,w:W,h:P,d:P});
  }

  // Supports (inside frame; avoid overlapping lintels)
  const addSupport=(where)=>{
    const on = where==='top'? S.topSupport : S.bottomSupport; if(!on) return;
    const orient= where==='top'? S.topOrient : S.bottomOrient;
    const size  = where==='top'? mm(S.topSize) : mm(S.bottomSize);
    const yPos  = where==='top' ? clamp(P + mm(S.topDrop), P, H-2*P)
                                 : clamp(H - 2*P - mm(S.bottomLift), P, H-2*P);
    if(orient==='X'){ // across width
      const zMid=(D-size)/2; M.boxes.push({type:'support',x:0,y:yPos,z:zMid,w:W,h:P,d:size});
    }else{            // front-to-back
      const xMid=(W-size)/2; M.boxes.push({type:'support',x:xMid,y:yPos,z:0,w:size,h:P,d:D-P});
    }
  };
  addSupport('top'); addSupport('bottom'); if(S.extraBottomBeam) addSupport('bottom');

  // Rails + bins (lip sits on rail)
  ch.forEach((c)=>{
    const xs=railXPositions(c);
    L.forEach((y,idx)=>{
      const allowBottom = (idx!==0 || S.bottomRowRails);
      if(allowBottom) xs.forEach(bx => M.boxes.push({type:'rail',x:bx,y,z:0,w:P,h:P,d:R}));
      if(S.showBins && allowBottom){
        const row=S.rows[idx]||{};
        const bodyW=Math.min(mm(S.binBody), c.w-2);
        const overall= bodyW + 2*mm(S.binFlange);
        const bx=c.x + (c.w - overall)/2;
        const lip=mm(S.binLip);
        const binH=mm(row.height ?? S.binHeightDefault);
        const over=mm(row.overhang ?? 0); // per-row overhang
        const gap=mm(row.gap ?? 0);        // per-row gap (clearance above)
        const dHere= Math.min(D + Math.max(0,over), D + over); // allow overhang
        const yTop = Math.max(0, y + P - lip); // seat by lip
        M.boxes.push({type:'bin',x:bx,y:yTop,z:0,w:overall,h:binH,d:dHere, gap});
      }
    });
  });

  // Bounds (frame components only; exclude bins so rotation pivots at frame center)
  const bMin=[Infinity,Infinity,Infinity];
  const bMax=[-Infinity,-Infinity,-Infinity];
  M.boxes.filter(b=>b.type!=='bin').forEach(b=>{
    bMin[0]=Math.min(bMin[0], b.x);
    bMin[1]=Math.min(bMin[1], b.y);
    bMin[2]=Math.min(bMin[2], b.z);
    bMax[0]=Math.max(bMax[0], b.x + b.w);
    bMax[1]=Math.max(bMax[1], b.y + b.h);
    bMax[2]=Math.max(bMax[2], b.z + b.d);
  });
  M.bounds = {min:bMin, max:bMax};
  // expose model for external consumers (e.g., views, debug panels)
  window.M = M;
  return M;
}

/* =====================
   3D renderer (canvas)
===================== */
const c3d = ()=>document.getElementById('c3d');
let yaw=0.5, pitch=0.3, zoom=1;

function sizeCanvas(cvs){
  const dpr=Math.max(1,window.devicePixelRatio||1);
  const r=cvs.getBoundingClientRect(); const w=Math.max(1,Math.floor(r.width*dpr)), h=Math.max(1,Math.floor(r.height*dpr));
  if(cvs.width!==w||cvs.height!==h){ cvs.width=w; cvs.height=h; cvs.getContext('2d').setTransform(dpr,0,0,dpr,0,0); }
}
function makeBoxFaces(x,y,z,w,h,d,color='#ddd',alpha=1,edge='#333'){
  const v=[[x,y,z],[x+w,y,z],[x+w,y+h,z],[x,y+h,z],[x,y,z+d],[x+w,y,z+d],[x+w,y+h,z+d],[x,y+h,z+d]];
  const q=[[0,1,2,3],[4,5,6,7],[0,4,7,3],[1,5,6,2],[0,1,5,4],[3,2,6,7]];
  return q.map(idx=>({pts:idx.map(i=>v[i]), color, alpha, edge}));
}
function drawGrid(ctx,w,h){
  ctx.fillStyle='#0e0e0e'; ctx.fillRect(0,0,w,h); ctx.strokeStyle='#1e1e1e';
  for(let x=0;x<w;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
  for(let y=0;y<h;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
}
function render3D(M){
  const cvs=c3d(); if(!cvs) return; const ctx=cvs.getContext('2d'); sizeCanvas(cvs); drawGrid(ctx,cvs.width,cvs.height);

  // faces from model
  const faces=[];
  M.boxes.forEach(b=>{
    const color = b.type==='post'?COLORS.post: b.type==='lintel'?COLORS.lintel: b.type==='rail'?COLORS.rail: b.type==='bin'?COLORS.bin: b.type==='support'?COLORS.support: b.type==='supportBatten'?COLORS.supportBatten:'#ddd';
    const alpha = b.type==='bin'?0.65:1;
    makeBoxFaces(b.x,b.y,b.z,b.w,b.h,b.d,color,alpha,'#333').forEach(f=>faces.push(f));
  });

  // fit - center on model bounds (exclude bins)
  const cx = (M.bounds.min[0] + M.bounds.max[0]) / 2;
  const cy = (M.bounds.min[1] + M.bounds.max[1]) / 2;
  const cz = (M.bounds.min[2] + M.bounds.max[2]) / 2;
  const radius = Math.sqrt(
    (M.bounds.max[0] - M.bounds.min[0])**2 +
    (M.bounds.max[1] - M.bounds.min[1])**2 +
    (M.bounds.max[2] - M.bounds.min[2])**2
  ) / 2;
  const f = 700, target = Math.max(1, Math.min(cvs.width, cvs.height) * 0.45);
  const camDist = Math.max(radius + 1, radius * (1 + f / target)) * Math.max(1, zoom);

  const rotY=(p,a)=>[p[0]*Math.cos(a)+p[2]*Math.sin(a),p[1],-p[0]*Math.sin(a)+p[2]*Math.cos(a)];
  const rotX=(p,a)=>[p[0],p[1]*Math.cos(a)-p[2]*Math.sin(a),p[1]*Math.sin(a)+p[2]*Math.cos(a)];
  const proj=pt=>{ const p0=[pt[0]-cx,pt[1]-cy,pt[2]-cz]; const p1=rotY(p0,yaw); const p2=rotX(p1,pitch); const z=camDist-p2[2]; const s=f/z; return [cvs.width/2+p2[0]*s, cvs.height/2-p2[1]*s, z]; };

  faces.forEach(f=>{ const tp=f.pts.map(proj); f.scr=tp.map(p=>[p[0],p[1]]); f.avgZ=tp.reduce((a,b)=>a+b[2],0)/tp.length; });
  faces.sort((a,b)=>b.avgZ-a.avgZ);

  ctx.lineWidth=1.2; faces.forEach(f=>{ ctx.beginPath(); f.scr.forEach((p,i)=> i?ctx.lineTo(p[0],p[1]):ctx.moveTo(p[0],p[1])); ctx.closePath(); ctx.fillStyle=f.color.startsWith('rgba')?f.color:rgba(f.color,f.alpha??1); ctx.strokeStyle=f.edge; ctx.fill(); ctx.stroke(); });
}
function bind3DInteractions(){
  const cvs=c3d(); if(!cvs) return;
  cvs.addEventListener('dblclick', ()=>{ yaw=0.5; pitch=0.3; zoom=1; renderAll(false); });
  cvs.addEventListener('wheel', e=>{ zoom=clamp(zoom+(e.deltaY>0?0.1:-0.1),0.5,3); renderAll(false); }, {passive:true});
  const pointers=new Map();
  let pinchDist=0,pinchZoom=1;
  const pos=e=>({x:e.clientX,y:e.clientY});
  const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);

  cvs.addEventListener('pointerdown',e=>{
    pointers.set(e.pointerId,pos(e));
    if(pointers.size===2){
      const [p1,p2]=Array.from(pointers.values());
      pinchDist=dist(p1,p2);
      pinchZoom=zoom;
    }
    cvs.setPointerCapture(e.pointerId);
  });

  cvs.addEventListener('pointermove',e=>{
    if(!pointers.has(e.pointerId)) return;
    const prev=pointers.get(e.pointerId), curr=pos(e);
    pointers.set(e.pointerId,curr);
    if(pointers.size===1){
      const dx=curr.x-prev.x, dy=curr.y-prev.y;
      yaw+=dx*0.01; pitch=clamp(pitch+dy*0.01,-1.1,1.1);
      renderAll(false);
    }else if(pointers.size===2){
      const [p1,p2]=Array.from(pointers.values());
      const d=dist(p1,p2);
      zoom=clamp(pinchZoom*(pinchDist/d),0.5,3);
      renderAll(false);
    }
  });

  function endPointer(e){
    pointers.delete(e.pointerId);
    if(pointers.size<2){
      pinchDist=0;
    }
  }
  cvs.addEventListener('pointerup',endPointer);
  cvs.addEventListener('pointerleave',endPointer);
  cvs.addEventListener('pointercancel',endPointer);
  document.getElementById('tbFit').onclick=()=>{ yaw=0.5; pitch=0.3; zoom=1; renderAll(false); };
  document.getElementById('tbPlus').onclick=()=>{ zoom=clamp(zoom-0.1,0.5,3); renderAll(false); };
  document.getElementById('tbMinus').onclick=()=>{ zoom=clamp(zoom+0.1,0.5,3); renderAll(false); };
  document.getElementById('tbReset').onclick=()=>{ yaw=0.5; pitch=0.3; zoom=1; renderAll(false); };
  document.getElementById('fit').onclick=()=>{ yaw=0.5; pitch=0.3; zoom=1; renderAll(false); };
}

/* =====================
   2D renderers (read model only)
===================== */
function size2D(cvs){ sizeCanvas(cvs); }
function drawDim(ctx,x1,y1,x2,y2,label,align='center',color='#ddd'){
  ctx.strokeStyle=color; ctx.fillStyle=color;
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  const mx=(x1+x2)/2,my=(y1+y2)/2;
  ctx.font='11px sans-serif'; ctx.textAlign=align; ctx.textBaseline='middle';
  ctx.fillText(label,mx,my);
}

function getElevationScale(M, h, pad){
  return (h-2*pad)/M.H;
}

function renderPlan(M){
  const cvs=document.getElementById('cplan'), ctx=cvs.getContext('2d'); size2D(cvs);
  const w=cvs.width,h=cvs.height; drawGrid(ctx,w,h);
  const pad=26, s=Math.min((w-2*pad)/M.W, (h-2*pad)/M.D), ox=pad, oy=pad;

  // Boundary & width
  ctx.strokeStyle=COLORS.line; ctx.strokeRect(ox,oy,M.W*s,M.D*s);
  drawDim(ctx,ox,oy-12,ox+M.W*s,oy-12,`W ${M.W} mm`);

  // Front posts
  M.boxes.filter(b=>b.type==='post' && b.z===0).forEach(b=>{
    ctx.fillStyle=COLORS.post; ctx.fillRect(ox+b.x*s, oy, b.w*s, M.D*s);
  });
  // support battens
  M.boxes.filter(b=>b.type==='supportBatten').forEach(b=>{
    ctx.fillStyle=COLORS.supportBatten; ctx.fillRect(ox+b.x*s, oy+b.z*s, b.w*s, b.d*s);
  });
  // Rear posts (hint)
  if(S.rearFrame){
    M.boxes.filter(b=>b.type==='post' && Math.abs(b.z-(M.D-M.P))<1e-3).forEach(b=>{
      ctx.save(); ctx.globalAlpha=.6; ctx.setLineDash([4,3]); ctx.strokeStyle=COLORS.dash;
      ctx.strokeRect(ox+b.x*s, oy+(M.D-b.d)*s, b.w*s, b.d*s); ctx.restore();
    });
  }

  // Channel labels vs target
  M.channels.forEach(c=>{
    const cx=ox+c.x*s, cw=c.w*s;
    const dev=Math.abs(c.w - S.openingTarget);
    const color=dev>=0.5?'#ff5555':'#ddd';
    drawDim(ctx,cx,oy+M.D*s+12,cx+cw,oy+M.D*s+12,`${c.w} mm`,'center',color);
    if(dev>=0.5){
      ctx.textBaseline='top'; ctx.fillStyle='#ff5555';
      ctx.fillText(`target ${S.openingTarget} → Δ${(c.w-S.openingTarget).toFixed(1)} mm`, cx, oy+M.D*s+24);
    }
  });

  // Rail footprints
  ctx.globalAlpha=.35; ctx.fillStyle='#2b66ff';
  M.boxes.filter(b=>b.type==='rail').forEach(b=>{ ctx.fillRect(ox+b.x*s, oy+b.z*s, b.w*s, b.d*s); });
  ctx.globalAlpha=1;
}

function renderFront(M){
  const cvs=document.getElementById('cfront'), ctx=cvs.getContext('2d'); size2D(cvs);
  const w=cvs.width,h=cvs.height; drawGrid(ctx,w,h);
  const pad=26, s=getElevationScale(M, h, pad), ox=pad, oy=pad;
  ctx.strokeStyle=COLORS.line; ctx.strokeRect(ox,oy,M.W*s,M.H*s);
  drawDim(ctx,ox,oy-12,ox+M.W*s,oy-12,`W ${M.W} mm`);
  drawDim(ctx,ox-12,oy,ox-12,oy+M.H*s,`H ${M.H} mm`,'right');

  // lintels front
  M.boxes.filter(b=>b.type==='lintel'&&b.z===0).forEach(b=>{ ctx.fillStyle=COLORS.lintel; ctx.fillRect(ox+b.x*s, oy+b.y*s, b.w*s, b.h*s); });
  // supports
  M.boxes.filter(b=>b.type==='support').forEach(b=>{ ctx.fillStyle=COLORS.support; ctx.fillRect(ox+b.x*s, oy+b.y*s, b.w*s, b.h*s); });
  // support battens
  M.boxes.filter(b=>b.type==='supportBatten').forEach(b=>{ ctx.fillStyle=COLORS.supportBatten; ctx.fillRect(ox+b.x*s, oy+b.y*s, b.w*s, b.h*s); });
  // rails
  M.boxes.filter(b=>b.type==='rail').forEach(b=>{ ctx.fillStyle=COLORS.rail; ctx.fillRect(ox+b.x*s, oy+b.y*s, b.w*s, b.h*s); });
  // posts front
  M.boxes.filter(b=>b.type==='post'&&b.z===0).forEach(b=>{ ctx.fillStyle=COLORS.post; ctx.fillRect(ox+b.x*s, oy+b.y*s, b.w*s, b.h*s); });
  // bins
  if(S.showBins) M.boxes.filter(b=>b.type==='bin').forEach(b=>{ ctx.fillStyle=COLORS.bin; ctx.fillRect(ox+b.x*s, oy+b.y*s, b.w*s, b.h*s); });
}

function renderSide(M){
  const cvs=document.getElementById('cside'), ctx=cvs.getContext('2d'); size2D(cvs);
  const w=cvs.width,h=cvs.height; drawGrid(ctx,w,h);
  const pad=26, s=getElevationScale(M, h, pad), ox=pad, oy=pad;

  ctx.strokeStyle=COLORS.line; ctx.strokeRect(ox,oy,M.D*s,M.H*s);
  drawDim(ctx,ox,oy-12,ox+M.D*s,oy-12,`D ${M.D} mm`);
  drawDim(ctx,ox-12,oy,ox-12,oy+M.H*s,`H ${M.H} mm`,'right');

  // supports
  ctx.fillStyle=COLORS.support;
  M.boxes.filter(b=>b.type==='support').forEach(b=>{
    ctx.fillRect(ox + b.z*s, oy + b.y*s, b.d*s, b.h*s);
  });
  // support battens
  ctx.fillStyle=COLORS.supportBatten;
  M.boxes.filter(b=>b.type==='supportBatten').forEach(b=>{
    ctx.fillRect(ox + b.z*s, oy + b.y*s, b.d*s, b.h*s);
  });
  // rails (depth × post)
  ctx.fillStyle=COLORS.rail;
  M.boxes.filter(b=>b.type==='rail').forEach(b=>{
    ctx.fillRect(ox + b.z*s, oy + b.y*s, b.d*s, b.h*s);
  });
  // bins (lip already baked into b.y)
  if(S.showBins){
    ctx.fillStyle=COLORS.bin;
    M.boxes.filter(b=>b.type==='bin').forEach(b=>{
      ctx.fillRect(ox + b.z*s, oy + b.y*s, b.d*s, b.h*s);
    });
  }
}

/* =====================
   Summary & Cut List
===================== */
function renderSummary(M){
  const el=document.getElementById('summary'); const C=M.channels.length;
  const postsFront=C+1, postsBack=S.rearFrame?(C+1):0, postsTot=postsFront+postsBack;
  const lintelsFront=2, lintelsBack=S.rearFrame?2:0, lintelsTot=lintelsFront+lintelsBack;
  const railsActual=M.boxes.filter(b=>b.type==='rail').length;
  const supportCount=M.boxes.filter(b=>b.type==='support').length;
  el.innerHTML=`<div><b>Overall</b> W ${M.W} × D ${M.D} × H ${M.H} mm</div>
    <div><b>Openings</b> ${M.channels.map(c=>c.w).join(' + ')} mm</div>
    <div><b>Posts</b> ${postsTot} <span class="ok">(front ${postsFront}${postsBack?` + back ${postsBack}`:''})</span></div>
    <div><b>Rails</b> ${railsActual}</div>
    <div><b>Lintels</b> ${lintelsTot} <span class="ok">(front ${lintelsFront}${lintelsBack?` + back ${lintelsBack}`:''})</span></div>
    <div><b>Supports</b> ${supportCount}</div>`;
}
function renderCutList(M){
  const parts={post:new Map(), lintel:new Map(), rail:new Map(), support:new Map()};
  M.boxes.forEach(b=>{
    if(!parts[b.type]) return;
    let len=0;
    if(b.type==='post') len=b.h;
    else if(b.type==='lintel') len=b.w;
    else if(b.type==='rail') len=Math.min(b.d, Math.min(S.runnerDepth,S.depth));
    else if(b.type==='support') len=Math.max(b.w,b.d);
    parts[b.type].set(len,(parts[b.type].get(len)||0)+1);
  });

  let html='<div><b>Cut List</b></div>';
  const labels={post:'Posts', lintel:'Lintels', rail:'Rails', support:'Supports'};
  for(const type of Object.keys(parts)){
    for(const [len,count] of [...parts[type]].sort((a,b)=>a[0]-b[0])){
      const note= type==='rail' ? ' (usable depth)' : '';
      html+=`<div>${labels[type]}: ${count} pcs — length <b>${len}</b> mm${note}</div>`;
    }
  }
  const el=document.getElementById('cutlist');
  el.innerHTML=html;
  el.classList.toggle('hidden', !S.showCutList);
  const btn=document.getElementById('toggleCutlist');
  if(btn) btn.textContent=`Cut List ${S.showCutList?'▣':'▢'}`;
}

function toggleCutlist(){
  S.showCutList=!S.showCutList;
  renderAll(false);
}

/* =====================
   UI bindings
===================== */
function bindInputs(){
  const num=(id,key,min=-Infinity,max=Infinity,cb)=>{ const el=document.getElementById(id); el.oninput=()=>{ S[key]=clamp(mm(el.value),min,max); if(cb) cb(); renderAll(); }; };
  const chk=(id,key)=>{ const el=document.getElementById(id); el.onchange=()=>{ S[key]=el.checked; renderAll(); }; };
  const sel=(id,key)=>{ const el=document.getElementById(id); el.onchange=()=>{ S[key]=el.value; renderAll(); }; };

  num('height','height',200,3000); document.getElementById('autoHeight').onchange=e=>{ S.autoHeight=e.target.checked; renderAll(); };
  num('depth','depth',50,2000); num('runnerDepth','runnerDepth',10,2000); num('post','post',10,200);
  chk('rearFrame','rearFrame');

  // Pattern text (normalized on use)
  document.getElementById('patternText').oninput=e=>{ S.patternText=e.target.value; renderAll(); };
  document.getElementById('addCol').onclick=()=>{
    const P=S.post; const seg=parseList(S.patternText); // append "open,P"
    const lastOpen = channels().at(-1)?.w ?? 283;
    let out=normalizeSegments(seg,P);
    out.splice(out.length-1,0,lastOpen,P); // insert before last post
    S.patternText=out.join(','); document.getElementById('patternText').value=S.patternText; renderAll();
  };
  document.getElementById('remCol').onclick=()=>{
    const P=S.post; let out=normalizeSegments(parseList(S.patternText),P);
    if(out.length>3){ out.splice(out.length-2,2); S.patternText=out.join(','); document.getElementById('patternText').value=S.patternText; renderAll(); }
  };

  // Rows UI
  function rebuildRowsUI(){
    const box=document.getElementById('rows'); box.innerHTML='';
    S.rows.forEach((r,i)=>{
      const wrap=document.createElement('div'); wrap.className='split';
      wrap.innerHTML=`
        <div class="ctl"><label>Row ${i+1} height</label><input value="${r.height}"></div>
        <div class="ctl"><label>Gap above</label><input value="${r.gap}"></div>
        <div class="ctl"><label>Overhang depth</label><input value="${r.overhang}"></div>`;
      const ins=wrap.querySelectorAll('input');
      ins[0].oninput=e=>{ S.rows[i].height=mm(e.target.value); renderAll(); };
      ins[1].oninput=e=>{ S.rows[i].gap=mm(e.target.value); renderAll(); };
      ins[2].oninput=e=>{ S.rows[i].overhang=mm(e.target.value); renderAll(); };
      box.appendChild(wrap);
    });
    document.getElementById('openingsView').textContent = channels().map(c=>c.w).join(' + ')+' mm';
  }
  rebuildRowsUI();
  document.getElementById('addRow').onclick=()=>{ S.rows.push({height:95,gap:10,overhang:0}); rebuildRowsUI(); renderAll(); };
  document.getElementById('remRow').onclick=()=>{ if(S.rows.length>1) S.rows.pop(); rebuildRowsUI(); renderAll(); };

  // Global clearances & rails
  num('topClear','topClear',0,2000); num('bottomClear','bottomClear',0,2000); chk('bottomRowRails','bottomRowRails');
  sel('railMode','railMode');

  // Supports
  chk('topSupport','topSupport'); sel('topOrient','topOrient'); num('topDrop','topDrop',0,2000); num('topSize','topSize',10,200);
  chk('bottomSupport','bottomSupport'); sel('bottomOrient','bottomOrient'); num('bottomLift','bottomLift',0,2000); num('bottomSize','bottomSize',10,200);
  chk('extraBottomBeam','extraBottomBeam');

  // Bin helper
  num('binBody','binBody',50,1200, refreshSuggestion); num('binFlange','binFlange',0,40, refreshSuggestion); num('binLip','binLip',0,30);
  num('binSlack','binSlack',0,50, refreshSuggestion); num('binHeightDefault','binHeightDefault',20,400); chk('showBins','showBins');
  function refreshSuggestion(){ const sug=Math.ceil(mm(S.binBody)+2*mm(S.binFlange)+mm(S.binSlack)); S.openingTarget=sug; document.getElementById('suggest').textContent=`Suggested opening: ${sug} mm`; renderAll(false); return sug; }
  document.getElementById('applyOpening').onclick=()=>{
    const v=refreshSuggestion(); const P=S.post; const arr=normalizeSegments(parseList(S.patternText),P);
    // rewrite all channel widths to suggested v (keep posts)
    const out=arr.map(n=> n===P?P:v);
    S.patternText=out.join(','); document.getElementById('patternText').value=S.patternText; S.openingTarget=v; renderAll(false); renderAll();
  };

  // View mode + cut list
  const app=document.getElementById('appRoot');
  function setView(mode){
    S.viewMode=mode;
    app.classList.toggle('single', mode!=='quad');
    ['pane-3d','pane-front','pane-side','pane-plan'].forEach(id=>document.getElementById(id).classList.remove('active'));
    if(mode==='quad'){ ['pane-3d','pane-front','pane-side','pane-plan'].forEach(id=>document.getElementById(id).classList.add('active')); }
    else{
      const map={ '3d':'pane-3d','plan':'pane-plan','front':'pane-front','side':'pane-side' };
      document.getElementById(map[mode]).classList.add('active');
    }
    renderAll(false);
  }
  window.setView = setView;
  document.getElementById('vmQuad').onclick=()=>setView('quad');
  document.getElementById('vm3d').onclick =()=>setView('3d');
  document.getElementById('vmPlan').onclick=()=>setView('plan');
  document.getElementById('vmFront').onclick=()=>setView('front');
  document.getElementById('vmSide').onclick =()=>setView('side');

  document.querySelectorAll('.tbView').forEach(btn=>{
    btn.onclick=()=>setView(S.viewMode==='quad'?btn.dataset.view:'quad');
  });

  document.getElementById('toggleCutlist').onclick=toggleCutlist;

  // initial
  refreshSuggestion();
}

/* =====================
   Tests (minimal, non-blocking)
===================== */
function runTests(M){
  const T=[], eq=(a,b,e=1e-6)=>Math.abs(a-b)<=e;
  const fallback='43,283,43,43,283,43,43';

  // parser
  T.push({name:'parser: mm suffix', pass:(()=>parseList('40mm,283,40').join(',')==='40,283,40')()});
  T.push({name:'parser: fallback', pass:(()=>parseList('x,y').join(',')===fallback)()});
  T.push({name:'normalize collapses double posts', pass:(()=>{const P=43; const n=normalizeSegments([P,283,P,P,283,P,P],P); return n.join(',')==='43,283,43,283,43';})()});

  // clamped dimensions
  T.push({name:'runner depth clamped', pass:S.runnerDepth<=S.depth});
  T.push({name:'rail depth clamped', pass:M.boxes.filter(b=>b.type==='rail').every(r=>r.d<=S.depth)});

  // component counts
  T.push({name:'post count', pass:(()=>{const expected=segments().filter(s=>s===S.post).length*(S.rearFrame?2:1); return M.boxes.filter(b=>b.type==='post').length===expected;})()});
  T.push({name:'lintel count', pass:(()=>{const expected=S.rearFrame?4:2; return M.boxes.filter(b=>b.type==='lintel').length===expected;})()});
  T.push({name:'rail count', pass:(()=>{const perOpening=(S.railMode==='centered'?1:2); const levelCount=S.rows.length-(S.bottomRowRails?0:1); const expected=channels().length*levelCount*perOpening; return M.boxes.filter(b=>b.type==='rail').length===expected;})()});

  const el=document.getElementById('tests');
  if(el) el.innerHTML=T.map(t=>`<div class="${t.pass?'ok':'ng'}">${t.pass?'✓':'✗'} ${t.name}</div>`).join('');
}

/* =====================
   Orchestrator
===================== */
function renderAll(rebuild=true){
  if(rebuild){
    S.runnerDepth=Math.min(mm(S.runnerDepth), mm(S.depth));
    M=buildModel();
  }
  render3D(M); renderPlan(M); renderFront(M); renderSide(M); renderSummary(M); renderCutList(M); runTests(M);
  document.getElementById('openingsView').textContent = channels().map(c=>c.w).join(' + ')+' mm';
}
function init(){
  bind3DInteractions();
  bindInputs();
  const isNarrow = window.matchMedia('(max-width: 600px)').matches;
  if(isNarrow) setView('3d');
  else renderAll();
}
window.addEventListener('DOMContentLoaded', init);
</script>
<script>
/* ---------- Alerts + hotkeys (no geometry changes) ---------- */
(function(){
  // Inject an "Alerts" panel just under the title in the sidebar
  const sidebar = document.getElementById('controls');
  const h1 = sidebar.querySelector('h1');
  const banner = document.createElement('div');
  banner.id = 'alerts';
  banner.className = 'grp';
  banner.innerHTML = '<h2>Alerts</h2><div id="alertMsgs" class="muted">No issues.</div>';
  sidebar.insertBefore(banner, h1 ? h1.nextSibling : sidebar.firstChild);

  function updateAlerts(){
    const msgs = [];
    const M = window.M;
    // 1) Pattern normalization (collapses accidental double posts)
    const arr = parseList(S.patternText);
    const norm = normalizeSegments(arr, S.post);
    if (norm.length !== arr.length || norm.some((v,i)=>v!==arr[i])) {
      msgs.push('Pattern normalized (duplicate posts collapsed): ' + norm.join(','));
    }
    // 2) Openings far from target
    const off = M.channels.filter(c => Math.abs(c.w - S.openingTarget) >= 0.5);
    if (off.length) msgs.push(`${off.length} opening(s) differ from target by ≥ 0.5 mm.`);
    // 3) Runner depth clamp info
    if (S.runnerDepth > S.depth) msgs.push(`Runner depth ${S.runnerDepth} clamped to carcass depth ${S.depth}.`);
    // 4) Bottom rails
    if (!S.bottomRowRails) msgs.push('Bottom row rails: OFF (first level has no rails).');
    // 5) Rows exceed manual height
    if (!S.autoHeight && M.rowOverflow) msgs.push('Rows exceed manual height.');

    // 6) Timber overlap
    const timber = M.boxes.filter(b => ['post','lintel','rail','support'].includes(b.type));
    outer: for(let i=0;i<timber.length;i++){
      for(let j=i+1;j<timber.length;j++){
        const a=timber[i], b=timber[j];
        if((a.type==='post'&&b.type==='lintel')||(a.type==='lintel'&&b.type==='post')) continue;
        if(a.x < b.x + b.w && a.x + a.w > b.x &&
           a.y < b.y + b.h && a.y + a.h > b.y &&
           a.z < b.z + b.d && a.z + a.d > b.z){
          msgs.push('Timber overlap detected.');
          break outer;
        }
      }
    }

    document.getElementById('alertMsgs').innerHTML =
      msgs.length ? msgs.map(m => `<div>• ${m}</div>`).join('') : 'No issues.';
  }

  // Hotkeys: 1..5 to change view, F for Fit, +/- for zoom
  window.addEventListener('keydown', (e)=>{
    if (e.target && ['INPUT','TEXTAREA','SELECT'].includes(e.target.tagName)) return;
    if (e.key === '1') document.getElementById('vmQuad').click();
    if (e.key === '2') document.getElementById('vm3d').click();
    if (e.key === '3') document.getElementById('vmPlan').click();
    if (e.key === '4') document.getElementById('vmFront').click();
    if (e.key === '5') document.getElementById('vmSide').click();
    if (e.key.toLowerCase() === 'f') document.getElementById('fit').click();
    if (e.key === '+') { zoom = clamp(zoom - 0.1, 0.5, 3); renderAll(false); }
    if (e.key === '-') { zoom = clamp(zoom + 0.1, 0.5, 3); renderAll(false); }
  });

  // Hook renderAll so alerts refresh every time
  const _renderAll = window.renderAll;
  window.renderAll = function(rebuild){
    _renderAll(rebuild);
    updateAlerts();
  };

})();
</script>
</body>
</html>
